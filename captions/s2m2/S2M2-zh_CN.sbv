0:00:07.000,0:00:10.000
S2 M2：与 Justin Thaler 探讨 sum-check 协议

0:00:10.716,0:00:12.680
Justin：嗨，我是 Justin Thaler。

0:00:12.680,0:00:16.920
我是乔治城大学的副教授，同时也是 a16z 的研究合作伙伴。

0:00:16.920,0:00:18.920
今天我要讲的是 sum-check 协议。

0:00:18.920,0:00:20.080
Tracy：酷。

0:00:20.080,0:00:20.680
我是 Tracy。

0:00:20.680,0:00:22.000
我是 Pluto 公司的联合创始人。

0:00:22.000,0:00:24.850
我一直致力于研究用于应用开发的零知识简洁非交互式知识论证系统（zk-SNARKs）。

0:00:24.850,0:00:29.720
Justin：好的。今天的主题是 sum-check 协议，

0:00:30.440,0:00:35.440
sum-check协议由隆德（Lund）、福特诺（Fortnow）、卡罗夫（Karloff）和尼桑（Nisan）提出

0:00:35.440,0:00:40.720
可追溯到可验证计算的早期，大约在1990年左右。

0:00:40.720,0:00:43.360
现在，它解决了以下问题，

0:00:43.360,0:00:47.040
这个问题你第一次看到时可能会觉得有点奇怪。

0:00:47.600,0:00:54.760
但其目标是计算以下形式的一个很大的求和。

0:00:54.760,0:00:58.760
我们对所有 n 位输入进行求和，

0:00:58.760,0:01:10.560
即对 x∈{0,1}ⁿ 的 g(x) 求和，其中 g 是某个 n 元多项式。

0:01:11.120,0:01:17.040
并且只有当 g 是“低次”时，该协议才会在一定程度上既安全又高效。

0:01:17.040,0:01:19.800
我们先别担心低次是什么意思。

0:01:20.760,0:01:28.000
从验证者的角度来看，sum-check 协议就像是一种归约。

0:01:28.000,0:01:31.680
这个求和涉及 2ⁿ 项。对吧？

0:01:31.680,0:01:34.160
验证者本可以自己计算这个和，

0:01:34.160,0:01:37.480
通过在 2ⁿ 个点上对 g 求值，然后自己求和。

0:01:37.480,0:01:40.640
验证者会想，“哦，这工作量太大了。我不想自己做。”

0:01:40.640,0:01:44.040
“我想让我不信任的证明者为我做这项工作。”

0:01:44.040,0:01:46.120
所以在 sum-check 协议中，验证者

0:01:46.120,0:01:50.200
最终只需要在一个点上对 g 求值。

0:01:50.200,0:01:55.040
但难点在于这个点是一个随机点，

0:01:55.040,0:01:57.680
而且随机性不只是来自 {0,1} 。

0:01:57.680,0:02:01.680
它来自一个大得多的空间，叫做有限域。

0:02:01.680,0:02:03.840
所以，再次强调，对于验证者来说，

0:02:03.840,0:02:09.680
sum-check 协议将这个对 g 进行 2ⁿ 次求值并求和的非常困难的任务，

0:02:09.680,0:02:12.480
简化为仅仅在一个点上对 g 求值的任务。

0:02:12.480,0:02:14.680
尽管，这个点来自整个域中的某个点，而不是

0:02:14.680,0:02:16.560
我们所称的 “布尔超立方体”。

0:02:16.560,0:02:17.708
Tracy：很酷。

0:02:17.708,0:02:19.200
Justin：有什么问题吗？
Tracy：说得通。我觉得很棒。

0:02:19.200,0:02:19.880
Justin：好的。

0:02:19.880,0:02:25.840
所以希望我们能明白为什么这个协议如此强大，

0:02:26.480,0:02:32.440
为什么低次多项式在证明系统中出现是有意义的。

0:02:32.440,0:02:34.280
我们要从最开始讲起。

0:02:34.280,0:02:36.480
我们先暂时忘掉 sum-check 协议

0:02:36.480,0:02:40.680
花几分钟时间只讲讲多项式。

0:02:40.680,0:02:41.800
好。

0:02:41.800,0:02:45.960
我们已经知道 sum-check 协议涉及到

0:02:45.960,0:02:48.320
多元多项式，n 元多项式。

0:02:48.320,0:02:52.360
但让我先回到基础，花一分钟

0:02:52.360,0:02:55.520
快速讲讲一元多项式。好吧？

0:02:55.520,0:03:01.240
一个 d 次一元多项式就是

0:03:01.240,0:03:09.760
系数乘以单个输入的相应幂次的总和。

0:03:09.760,0:03:15.040
这就是我刚刚写下的 d 次一元多项式。

0:03:15.040,0:03:17.860
Tracy: 这就像经典的项的线性组合。

0:03:17.860,0:03:18.800
Justin: 没错。

0:03:18.800,0:03:21.600
这被称为标准单项式基。

0:03:21.600,0:03:24.800
这些系数是 x 的幂次的系数。

0:03:24.800,0:03:28.360
还有其他一些同样值得考虑的基，

0:03:28.920,0:03:31.320
正如我们将在 Sum-Check 协议中看到的，

0:03:31.320,0:03:33.720
“拉格朗日基”更有意义，

0:03:33.720,0:03:36.800
但我们先从人们最熟悉的内容开始讲起。

0:03:36.800,0:03:41.320
在标准单项式基下的 d 次一元多项式。

0:03:41.320,0:03:41.480
好。

0:03:41.480,0:03:45.640
一个基本事实——我一直记不清这到底是代数基本定理，

0:03:45.640,0:03:49.760
还是八九年级学过的内容——

0:03:49.760,0:03:58.880
但是如果 p 和 q 是两个不同的，

0:03:58.880,0:04:07.000
（最高）次数为 d 次的多项式，

0:04:07.000,0:04:11.080
那么它们几乎在所有的输入上都会不一致。

0:04:11.080,0:04:20.480
所以这意味着 p(x) = q(x) 最多在 --

0:04:21.320,0:04:24.400
就像两条不同的直线，可能在一个点上相交——

0:04:24.400,0:04:29.160
所以最多在 d 个点相交。

0:04:30.920,0:04:31.240
很好。

0:04:31.240,0:04:35.040
所以，这只是换一种说法，
实际上只是对以下事实的重新表述：

0:04:35.040,0:04:39.320
任何非零的 d 次多项式最多有 d 个根。

0:04:39.320,0:04:39.600
对吧？

0:04:39.600,0:04:46.120
因为 p(x) = q(x) 等价于 (p-q)(x) = 0。

0:04:46.120,0:04:49.000
所以讨论 p 和 q 的交点（agreement points），

0:04:49.000,0:04:50.680
就等同于讨论 p 减 q 的根。

0:04:50.680,0:04:51.520
Tracy: 对的。

0:04:51.520,0:04:53.560
所以如果它们共享根，那么在这些点上它们相等。

0:04:53.560,0:04:54.760  
但在其他任何地方它们都会有所不同。

0:04:54.760,0:04:56.960  
Justin：对，没错。

0:04:56.960,0:05:02.520  
这几乎是你设计高效交互式证明所需的唯一事实。

0:05:02.520,0:05:07.360  
尽管交互式证明使用多元多项式，

0:05:07.360,0:05:10.280  
但每一轮交互实际上都涉及一个一元多项式。

0:05:10.280,0:05:15.240  
因此，在大多数情况下，你只需要应用这个一元多项式的性质。

0:05:15.240,0:05:19.720  
这个性质在多元多项式的情况下有个类似版本，称为施瓦茨-齐佩尔引理（Schwartz–Zippel lemma），

0:05:19.720,0:05:23.080  
可能会在本次课程的后续内容中提到。

0:05:23.080,0:05:26.080  
但无论如何，这基本上就是你需要知道的全部内容。

0:05:26.080,0:05:29.000  
所以，不会超过八年级的水平。

0:05:29.000,0:05:29.702  
Tracy：酷。

0:05:29.702,0:05:30.240  
Justin：太棒了。

0:05:30.240,0:05:32.240  
这就是一元多项式。

0:05:32.240,0:05:40.760  
但正如已经提到的，Sum-Check 协议使用的是多元多项式。

0:05:40.760,0:05:49.880  
因此，引入多线性多项式的概念是有帮助的。

0:05:49.880,0:05:53.000  
现在，你不需要了解多线性多项式

0:05:53.000,0:05:54.560  
就能理解 sum-check 协议。

0:05:54.560,0:05:59.640  
但要理解该该协议的应用，通常就需要了解它们了。

0:05:59.640,0:06:02.280  
通常，Sum-Check 所应用的多项式

0:06:02.280,0:06:06.360  
是由几个多线性多项式构成的。

0:06:06.360,0:06:10.760  
因此，为了理解 Sum-Check 是如何应用的，我们确实需要讨论一下。

0:06:10.760,0:06:27.920  
那么，简单来说，多线性多项式就是每个变量的次数至多为 1 的 n 元多项式。

0:06:27.920,0:06:28.560  
好的。

0:06:31.240,0:06:33.920  
下面举一个多线性多项式的例子，

0:06:33.920,0:06:39.400  
假设有三个变量，x₁、x₂ 和 x₃，可以是

0:06:39.400,0:06:48.120  
比如 3 * x₁ * x₂ * x₃ + x₁ * x₂。

0:06:48.120,0:06:54.200  
好。但如果我加入一个 x₁² 的项，它就不再是多线性多项式了。

0:06:54.200,0:06:55.560  
好的。  
Tracy：因为那一项不是线性的。

0:06:55.560,0:06:59.720  
Justin：是的。因为单个变量的指数是 2。

0:06:59.720,0:07:00.440  
你知道，就是说——

0:07:00.440,0:07:03.080  
如果指数是 3，它同样不是多线性的。

0:07:03.080,0:07:05.640  
因此，只要你查看每个变量，

0:07:05.640,0:07:09.340  
并且它在每一项中的指数都是 1，那么它就是多线性的。

0:07:09.340,0:07:10.720  
Tracy：明白了。

0:07:10.720,0:07:11.720  
Justin：好的。

0:07:12.680,0:07:16.200  
既然我们现在讨论的是多线性多项式，

0:07:16.200,0:07:23.200  
我们不妨也讨论一下所谓的“多线性扩展”。

0:07:23.200,0:07:23.960  
好的。

0:07:23.960,0:07:28.040  
我接下来要描述的内容，其动机源自于

0:07:28.040,0:07:30.840  
Sum-Check 协议计算的是

0:07:30.840,0:07:35.480  
布尔超立方体 {0,1}ⁿ 中的输入之和这一事实。

0:07:35.480,0:07:35.640  
好。

0:07:35.640,0:07:40.160  
我在这里画一个二元多项式的示例。

0:07:40.160,0:07:43.240  
比如说——

0:07:43.240,0:07:45.240  
好的。那么，对——

0:07:45.880,0:07:46.560  
对，就是这样。

0:07:46.560,0:07:52.135  
先把多项式放一放——

0:07:52.135,0:07:52.560  
暂时别考虑多项式。

0:07:52.560,0:07:58.520  
假设我们有一个函数，其定义域是 {0,1} * {0,1}。

0:07:58.520,0:08:01.800  
那么这个函数只有四种可能的输入。

0:08:01.800,0:08:04.720  
它的输出值属于某个有限域。

0:08:04.720,0:08:09.080  
如果你对域不熟悉，可以将其输出视为数字，

0:08:09.080,0:08:10.840  
比如整数之类的。

0:08:10.840,0:08:12.640  
好。我来画一下这里的函数 f。

0:08:12.640,0:08:23.000  
假设我将（0,0）映射到2，（0,1）映射到 3，（1,0）映射到 4，（1,1）映射到 5。

0:08:23.000,0:08:29.160  
好。所以如果给我任何一个定义域为布尔超立方体的函数，

0:08:29.160,0:08:32.760  
即，对于任意 n 的 {0,1}ⁿ，这里  n 是 2，

0:08:32.760,0:08:40.360  
总会存在一个唯一的多线性多项式，

0:08:40.360,0:08:44.280  
当仅在这个超立方体上考察该多项式时, 

0:08:44.280,0:08:48.360  
它与该函数的表现一致。

0:08:48.360,0:08:52.160
记住，你可以在超立方体之外评估多项式，

0:08:52.160,0:08:56.600
但我们“扩展”的这个函数只在超立方体上有定义。

0:08:56.600,0:08:57.380  
Tracy：我明白了。

0:08:57.380,0:08:57.840  
Justin：好的。

0:08:57.840,0:09:01.200  
所以只存在唯一的多线性扩展。

0:09:02.080,0:09:07.240  
这意味着一个多线性多项式 p，

0:09:07.240,0:09:14.360  
使得对于 f 定义域内的所有 x，都有 p(x) = f(x)，

0:09:14.360,0:09:16.480  
而 f 的定义域就是布尔超立方体。

0:09:16.480,0:09:23.000  
那么在这个例子中，我可以画出多线性扩展的求值情况。

0:09:23.000,0:09:26.720  
函数 f 只有四个输入，而对于 p，我可以输入——

0:09:26.720,0:09:31.740  
你知道，对于它的两个变量中的每一个，我都可以输入任意的域元素。

0:09:31.740,0:09:31.752  
Tracy：好的。

0:09:31.752,0:09:36.880  
Justin：所以多项式 p 的数量就像将行数从 2 扩展到域大小，

0:09:36.880,0:09:41.040  
将列数也从 2 扩展到域大小。

0:09:41.040,0:09:44.040  
所以如果这个域的大小是 2^128 之类的，

0:09:44.040,0:09:47.700  
那么行数就会一直延伸，几乎无穷无尽。

0:09:47.700,0:09:53.320  
Tracy：所以目标几乎是将求值域缩小到这个较小的域？

0:09:53.320,0:09:54.400  
Justin：我觉得——

0:09:54.400,0:09:56.760  
如果你从定义域较小的函数 f 开始，

0:09:56.760,0:10:00.500  
那么 p 的目标是将 f 的定义域扩展到更大的域。

0:10:00.500,0:10:01.200  
Tracy：我明白了。

0:10:01.200,0:10:01.340  
好的。

0:10:01.340,0:10:04.633  
Justin：如果你从 p 出发得到 f，那就是把 p 的定义域缩小到——

0:10:04.633,0:10:05.680  
Tracy：是的。
我在想这个。

0:10:05.680,0:10:07.720  
这个（p）有完整域的定义域，

0:10:07.720,0:10:10.026  
而这个（f）有较小的定义域，确实是这样。

0:10:10.026,0:10:12.200  
Justin：对。对。 所以通常我们关心的函数，

0:10:12.200,0:10:15.800  
那些我们想用 Sum-Check 来计算的函数，

0:10:15.800,0:10:18.800  
是定义在布尔域上的，即较小的定义域。

0:10:19.360,0:10:27.720  
而我们想要处理多项式的原因是为了距离放大的目的。

0:10:27.720,0:10:35.280  
大致来说，如果定义在超立方体上的任意两个函数哪怕在单个求值点上不同，

0:10:35.280,0:10:39.400  
那么它们的多线性扩展也会不同。

0:10:39.400,0:10:43.080  
因此，如果存在两个不同的低次多项式，它们不同，

0:10:43.080,0:10:45.580  
那么它们在大的定义域上几乎处处不一致。

0:10:45.580,0:10:46.140  
Tracy：很有道理。

0:10:46.140,0:10:48.080  
Justin：所以这是一种距离放大的机制。

0:10:48.080,0:10:49.040  
Tracy：好的。

0:10:49.040,0:10:52.160  
Justin：所以我写了这个，实际上很容易写出来，

0:10:52.160,0:10:54.920  
弄清楚多线性扩展的样子。

0:10:54.920,0:10:57.400  
在任何方向上它都是线性的，对吧？

0:10:57.400,0:11:02.560  
所以如果你从 2 到 4，差值是 2。

0:11:03.200,0:11:05.280  
如果再进一步，就是 6。

0:11:07.600,0:11:10.120  
如果再进一步，就是 8，以此类推。

0:11:10.120,0:11:13.480  
同样，3 到 5，这个差值是 2。所以 7 和 9——

0:11:13.480,0:11:17.680  
然后在这个方向上，从 2 到 3，一步是从 2到 3。

0:11:17.680,0:11:19.600  
所以再进一步，就是 4。

0:11:19.600,0:11:22.440  
如果再进一步，就是 5，以此类推。

0:11:22.440,0:11:29.400  
所以从左到右，每次增加 1，从上到下每次增加2。

0:11:29.400,0:11:30.540  
这就是多线性扩展。

0:11:30.540,0:11:32.200  
Tracy：我明白了。好的。

0:11:32.200,0:11:38.000  
Justin：现在注意，任何定义在小定义域上的函数

0:11:38.000,0:11:42.720  
都有许多多项式可以扩展它，但只有一个是多线性的。

0:11:42.720,0:11:43.360  
好的。

0:11:43.360,0:11:46.880  
所以对于这个具体的例子，

0:11:46.880,0:11:50.800  
我实际上会写出多线性扩展的表达式，

0:11:50.800,0:11:54.760  
然后给你一个不是多线性的扩展。

0:11:54.760,0:11:57.680  
也许我们之后会做一个简单的例子，

0:11:57.680,0:11:59.240  
然后我们就可以开始讨论 Sum-Check 了。

0:12:00.160,0:12:00.680  
好的。

0:12:00.680,0:12:07.480  
所以对于这个图，多线性扩展可以写成如下形式。

0:12:07.480,0:12:07.880  
这是——

0:12:07.880,0:12:10.760  
我要做的是一个叫做拉格朗日插值的过程，

0:12:10.760,0:12:12.920  
虽然这个名字并不重要。

0:12:12.920,0:12:14.520  
所以——

0:12:14.520,0:12:19.620  
好的。这个函数将输入（0,0）映射到 2。

0:12:19.620,0:12:20.420  
Tracy：是的。

0:12:20.420,0:12:20.800  
Justin：好的。

0:12:20.800,0:12:21.793  
所以第一项——

0:12:21.793,0:12:24.360  
Tracy：所以你正在做的是，给定这个域，

0:12:24.360,0:12:27.640  
我要创建一个多项式来拟合这些求值结果，

0:12:27.640,0:12:29.403  
或者说在这个定义域上进行求值。

0:12:29.403,0:12:30.320  
Justin：没错。

0:12:30.320,0:12:31.040  
Tracy：是的。

0:12:31.040,0:12:32.760  
Justin：所以——

0:12:32.760,0:12:36.880  
是的。所以为了确保多项式将（0,0）映射到 2，

0:12:36.880,0:12:41.840  
我要写一个2 * (1-x₁) * (1-x₂)。

0:12:41.840,0:12:43.720  
Tracy：所以你把这个作为一个根。

0:12:43.720,0:12:50.000  
Justin：嗯，我们做的是在没有 2 的情况下，这个表达式会选出输入（0,0）。

0:12:50.000,0:12:50.520  
Tracy：我明白了。

0:12:50.520,0:12:50.792  
好的。是的。

0:12:50.792,0:12:53.240  
Justin：所以（0,0）映射到 1，而其他任何布尔输入则不会。

0:12:53.240,0:12:54.600  
Tracy：好的。这就像开关一样。

0:12:54.600,0:12:58.040  
本质上是在说，我要把 2 打开。

0:12:58.040,0:13:00.080  
所以实际上就是把 2 打开。

0:13:00.080,0:13:02.360  
然后你会再写一次，把 3 打开。

0:13:02.360,0:13:03.480  
Justin：对，是的。

0:13:03.480,0:13:08.080  
所以这个表达式只是把输入（0,0）打开，其他所有输入关闭。

0:13:08.080,0:13:10.873  
然后 2 表示乘以 2，得到 2。

0:13:10.873,0:13:11.920  
Tracy：得到 2。

0:13:11.920,0:13:17.480  
Justin：然后如果我想把输入（0,1）打开，我会把它乘以 3。

0:13:17.480,0:13:20.840  
所以我用 1-x₁ 来确保 0 是打开的。

0:13:20.840,0:13:21.480  
Tracy：是的。

0:13:21.480,0:13:23.740  
Justin：乘以 x₂ 来确保 1 是打开的。

0:13:23.740,0:13:25.000  
Tracy：明白了。

0:13:25.000,0:13:32.000  
Justin：然后我们有4 * x₁ * (1-x₂)，

0:13:32.000,0:13:34.800  
它把（1,0）打开并映射到4。

0:13:34.800,0:13:40.960  
最后是 5 * x₁ * x₂，它把（1,1）打开。

0:13:40.960,0:13:42.027  
Tracy：明白了。好的。

0:13:42.027,0:13:44.360  
Justin：是的。这就是拉格朗日插值。

0:13:44.360,0:13:48.080  
但要明确的是，这是唯一的

0:13:48.080,0:13:53.040  
扩展这个二元函数 f 的多线性多项式。

0:13:53.040,0:13:53.760  
Tracy：好的。

0:13:53.760,0:13:55.360  
Justin：但我可以添加一些东西——

0:13:55.360,0:14:00.040  
如果我不想让它是多线性的，我可以添加各种东西，

0:14:00.040,0:14:03.320  
并保持其在小定义域上的行为不变。对吧？

0:14:03.320,0:14:07.680  
所以我可以添加像 x₁ * (1-x₁) 这样的项，

0:14:07.680,0:14:12.059  
在小定义域上，没有任何变化，因为在小定义域上这个表达式等于0。

0:14:12.059,0:14:12.920  
Tracy：我明白了。  
Justin：对。

0:14:12.920,0:14:16.280  
x₁ 等于 0 会使这个项消失。x₁ 等于 1 也会使这个项消失。

0:14:16.280,0:14:17.000  
Tracy：是的。

0:14:17.000,0:14:21.520  
Justin：所以有无限多个非多线性扩展，

0:14:21.520,0:14:25.260  
但只有一个唯一的多线性扩展。

0:14:25.260,0:14:26.880  
Tracy：有趣。好的。

0:14:26.880,0:14:27.760  
Justin：很好。

0:14:27.760,0:14:32.520  
再次强调，这些扩展多项式在证明系统中如此有用的原因是，

0:14:32.520,0:14:36.320  
如果证明者在任何小细节上撒谎，

0:14:36.320,0:14:39.200  
验证者需要能够识破这个谎言。

0:14:39.200,0:14:42.560  
所以我们需要将完全正确的东西和稍微有点偏差的东西之间的微小差异

0:14:42.560,0:14:46.640  
放大成巨大的差异。

0:14:46.640,0:14:50.120  
所以再比如说，如果你取两个不同的函数，

0:14:50.120,0:14:53.240  
即使它们在小定义域上只有一个输入不同，

0:14:53.240,0:14:56.860  
它们的多线性扩展几乎在所有地方都会不同。

0:14:56.860,0:14:56.872  
Tracy：是的。

0:14:56.872,0:14:59.040  
Justin：所以如果你在一个随机点上查看它们，它们会不同。

0:0:14:59.040,0:15:00.640  
Tracy：是的。明白了。

0:15:00.640,0:15:02.160  
Justin：好的。

0:15:02.160,0:15:03.549  
再举一个例子——

0:15:03.549,0:15:04.400  
Tracy：抱歉打断一下

0:15:04.400,0:15:05.240  
这里的目标实际上是——

0:15:05.240,0:15:07.800  
这里的目标实际上是证明——

0:15:07.800,0:15:09.960  
是让验证者能够证明

0:15:09.960,0:15:14.240  
证明者在其所有操作中都使用了这个多项式。

0:15:14.240,0:15:17.240  
Justin：最终，在零知识简洁非交互式知识论证系统（SNARKs）中大致就是这样。

0:15:17.240,0:15:21.000  
随着我们看到 Sum-Check 的应用，这一点会变得更加清晰。

0:15:21.000,0:15:21.960  
Tracy：好的。

0:15:21.960,0:15:26.040  
也许我想理解的一点是，这确实有道理，

0:15:26.040,0:15:28.280  
它涵盖了这个定义域。

0:15:30.000,0:15:32.360  
这就是多线性扩展吗？

0:15:32.360,0:15:35.300  
添加这些额外的项是在扩展它吗？

0:15:35.300,0:15:40.160  
Justin：哦，不是。当你添加非多线性项时，你仍然得到一个扩展，

0:15:40.160,0:15:42.900  
意味着它在小定义域上有正确的行为。

0:15:42.900,0:15:43.920  
Tracy：对。

0:15:43.920,0:15:45.760  
Justin：但它不再是多线性的了。

0:15:45.760,0:15:48.760  
所以这里，没有任何——

0:15:48.760,0:15:55.480  
这是将（0,0）映射到 2，（0,1）映射到 3，（1,0）映射到 4，（1,1）映射到 5 的 f 的多线性扩展。
  
0:15:55.480,0:15:56.540  
就是这个。这是多线性的。

0:15:56.540,0:15:57.300  
Tracy：好的。明白了。

0:15:57.300,0:15:59.000
贾斯汀：还有其他不是多线性的扩展。

0:15:59.000,0:16:01.920  
Tracy：我明白了。好的。

0:16:01.920,0:16:02.780  
好的。很酷。

0:16:02.780,0:16:06.280  
Justin：很好。现在，我再举一个例子。

0:16:06.280,0:16:09.460  
这是一个非常重要的例子。我称之为相等函数。

0:16:09.460,0:16:10.180  
Tracy：好的。

0:16:10.180,0:16:12.440  
Justin：好的。所以这里，这个函数将接受——

0:16:12.440,0:16:19.600  
这个函数将接受两个输入，比如说 x和 y。

0:16:19.600,0:16:27.000  
也就是 eq(x, y)，其中 x 和 y 都在{0,1}ⁿ中。

0:16:27.000,0:16:32.880  
好的。它将输出——

0:16:32.880,0:16:40.020  
我们定义 eq 在 x 和 y 是相同向量时输出 1，否则输出 0。

0:16:40.020,0:16:43.080  
Tracy：我明白了。好的。

0:16:43.080,0:16:46.673  
Justin：好的。那么它的多线性扩展——

0:16:46.673,0:16:51.180  
Tracy：所以它的形式会与这个不同，它的形式要体现出这个特性。

0:16:51.180,0:16:52.720  
Justin：对。对。没错。

0:16:52.720,0:16:55.600  
所以注意一下项数——

0:16:55.600,0:16:59.680  
当我做拉格朗日插值时，项数是 2ⁿ。对吧？

0:16:59.680,0:17:02.900  
小定义域中的每个输入都对应一个项。

0:17:02.900,0:17:02.912  
Tracy：是的。

0:17:02.912,0:17:09.660  
Justin：我们会发现 eq 的多线性扩展实际上可以在时间 n 内求值。

0:17:09.660,0:17:10.380  
Tracy：我明白了。

0:17:10.380,0:17:12.920  
Justin：好的。所以基本上，如果你有性质非常好的函数，

0:17:12.920,0:17:15.640  
你可以比按照拉格朗日插值定义逐项计算

0:17:15.640,0:17:19.400  
更快地对它们求值。

0:17:19.400,0:17:20.320  
所以——

0:17:20.320,0:17:22.920  
顺便说一下，每当我有一个定义在小定义域上的函数，

0:17:22.920,0:17:25.320
并且我想引用它的多线性扩展多项式时，

0:17:25.320,0:17:27.000  
我只需要在上面加一个波浪号。

0:17:27.000,0:17:28.440  
所以这不是一个多项式。

0:17:28.440,0:17:31.840  
它只是定义在布尔超立方体上的一个函数。

0:17:31.840,0:17:35.040 
如果我在上面加一个波浪号，它就是一个多项式。

0:17:35.040,0:17:35.352 
Tracy：好的。

0:17:35.352,0:17:38.040  
Justin：那么——

0:17:38.040,0:17:43.320  
对，假设这里的输入是 x₁ 到 xₙ，y₁ 到 yₙ。

0:17:43.320,0:17:44.240  
好的。这是什么呢？

0:17:44.240,0:17:46.240  
那么——

0:17:46.240,0:17:52.640  
我先直接写出来，然后我们会解释为什么这个等式成立。

0:17:52.640,0:17:56.320  
所以我们有 xᵢ—— 这是 n 个项的乘积，

0:17:56.320,0:18:03.960  
其中第 i 项是xᵢ * yᵢ + (1 - xᵢ) * (1 - yᵢ)。

0:18:03.960,0:18:05.200  
明白吗？

0:18:05.200,0:18:09.280  
我们可以称之为一个断言，因为我还没有解释为什么这是正确的。

0:18:09.280,0:18:10.120
Tracy：是的。

0:18:10.120,0:18:10.800
Justin：好的。

0:18:10.800,0:18:14.720
要理解为什么这是正确的，你只需要检查两件事。

0:18:14.720,0:18:18.200
第一，检查右边是否是一个多线性多项式。

0:18:18.200,0:18:19.600
它确实是。对吧？

0:18:19.600,0:18:21.840
因为每一项的次数都是 1。

0:18:21.840,0:18:23.040
Tracy：是的。

0:18:23.040,0:18:23.880
Justin：对。这个——

0:18:23.880,0:18:28.480
乘积中的任何两项都涉及不同的变量。所以没有变量的次数是 2。

0:18:28.480,0:18:34.760
所以，为了确认它是这个相等函数的多线性扩展，我们要做的就是，

0:18:34.760,0:18:39.000
确保当你输入任意两个布尔向量 x 和 y 时，

0:18:39.000,0:18:42.480
这个多项式输出的结果与相等函数输出的结果一致。

0:18:42.480,0:18:43.300
Tracy：是的。我明白了。

0:18:43.300,0:18:46.720
Justin：好的。所以这里做的是，我们对每一位进行检查。

0:18:46.720,0:18:49.320
Tracy：所以这个结果总是 0 或 1。

0:18:49.320,0:18:49.920
Justin：是的。

0:18:49.920,0:18:50.490
Tracy：对。

0:18:50.490,0:18:55.800
Justin：所以第 i 项只是检查 x 的第 i 位是否等于 y 的第 i 位。

0:18:55.800,0:18:57.181
如果它们都是 1，那么这一项输出 1，另一项输出 0，结果是 1。

0:18:57.181,0:19:03.240
如果它们都是 0，那么这一项输出 0，另一项输出1 。

0:19:03.240,0:19:07.880
如果一个是 0，另一个是 1，那么这两项都是 0。

0:19:07.880,0:19:12.400
所以将它们相乘就是在检查，对于每一个 i，xᵢ 是否等于 yᵢ。

0:19:12.400,0:19:12.920
这就是相等检查。

0:19:12.920,0:19:13.520
Tracy：对。

0:19:13.520,0:19:16.746
Justin：这是一种将相等性检查编码成多项式的方法。

0:19:16.746,0:19:17.108
Justin：是的。完全正确。

0:19:17.108,0:19:17.935
Tracy：编码到一个多线性——

0:19:17.935,0:19:18.660
Justin：完全正确——
Tracy：扩展的多项式中。

0:19:18.660,0:19:19.160
Justin：完全正确。

0:19:19.160,0:19:19.560
Tracy：明白了。

0:19:19.560,0:19:20.320
Justin：所以这是一个——

0:19:20.320,0:19:24.240
这在 Sum-Check 协议的许多应用中都会出现。

0:19:24.240,0:19:27.640
而且，还有其他很好的例子可以帮助更好地理解。

0:19:27.640,0:19:28.840
如果我只用 2——

0:19:28.840,0:19:31.360
Tracy：这是相等检查吗？

0:19:31.360,0:19:33.160
它是这么叫的吗，还是？

0:19:33.160,0:19:35.560
我猜它最终会以某种方式实现相等性检查。

0:19:35.560,0:19:37.280
Justin：是的。相等性——

0:19:37.280,0:19:40.160
所以这在很多地方都很有用——

0:19:40.160,0:19:46.160
但特别是在我们称之为零检查的地方，我们很快就会看到。

0:19:46.160,0:19:50.619
基本上，零检查意味着你想检查是否所有东西都等于零。

0:19:50.619,0:19:50.632
Tracy：我明白了。

0:19:50.632,0:19:53.600
Justin：所以你测试的是是否等于零之类的测试。对。

0:19:54.480,0:19:55.480
再举最后一个例子，

0:19:55.480,0:20:03.320
假设我想计算两个输入 x₁ 和 y₁ 的 OR，，那么——

0:20:03.320,0:20:09.960
它的多线性扩展是 x₁ + y₁ - x₁ * y₁。

0:20:09.960,0:20:11.080
你可以——你知道，你可以——

0:20:11.080,0:20:12.520
它只有四种可能的输入。

0:20:12.520,0:20:12.870
你可以——

0:20:12.870,0:20:15.260
Tracy：如果遍历真值表，会发现这个式子是成立的。

0:20:15.260,0:20:15.940
Justin：对。是的。

0:20:15.940,0:20:16.400
Tracy：好的。

0:20:16.400,0:20:18.880
Justin：是的。所以还有其他一些简单的例子值得一看，

0:20:18.880,0:20:22.760
比如 XOR、AND 运算——只要熟悉它们就行。

0:20:23.920,0:20:27.000
好的。所以这只是为了让大家熟悉多元多项式，

0:20:27.000,0:20:28.440
特别是多线性多项式。

0:20:28.440,0:20:30.420
现在我们准备好讨论 Sum-Check 协议了。

0:20:30.420,0:20:32.240
Tracy：好的。

0:20:32.240,0:20:33.800
Justin：好。

0:20:33.800,0:20:38.840
我们来看看 Sum-Check 协议是如何工作的，然后再看看它的一些应用。

0:20:38.840,0:20:42.920
记住，Sum-Check 协议的目标是计算

0:20:42.920,0:20:52.840
对于某个“低次”多项式 g 和 n 个变量，计算所有 x∈{0,1}ⁿ 的 g(x) 之和。

0:20:52.840,0:20:57.000
同样，在看到一些应用时，那时你会知道这个 g 是什么。

0:20:57.000,0:21:00.280
不过，我要提到的是，在大多数 SNARK 应用中，

0:21:00.920,0:21:06.840
你可以大致认为求和中的项数——

0:21:06.840,0:21:10.880
也即，求和的项数，你可以认为

0:21:10.880,0:21:17.360
与证明者所声称的电路规模有关。

0:21:17.360,0:21:19.880
所以电路中的一个门对应求和中的一项，

0:21:19.880,0:21:23.080
或者约束系统中的一个约束对应求和中的一项，

0:21:23.080,0:21:30.440
这意味着变量数 n，是电路规模、

0:21:30.440,0:21:34.866
约束数量或其他类似量的对数。

0:21:34.866,0:21:39.880
Tracy：对。好的。所以我们有一个长度为 2ⁿ 的电路。

0:21:39.880,0:21:42.240
Justin：是的。没错。

0:21:42.240,0:21:47.980
所以记住，在 Sum-Check 中，我们将看到每一轮对应一个变量。

0:21:47.980,0:21:47.992
Tracy：对。

0:21:47.992,0:21:54.040
Justin：好的。这意味着在 SNARK 应用中，一轮——有电路规模的对数那么多轮。

0:21:54.040,0:21:55.400
所以在基于 Sum-Check 的 SNARK 中，

0:21:55.400,0:21:58.980  
验证者的运行时间大致是电路大小的对数级。

0:21:58.980,0:21:59.580  
Tracy：明白了。

0:21:59.580,0:22:00.920  
Justin：这实际上相当不错。

0:22:00.920,0:22:04.720  
你知道，有很多多项式对数比对数大得多，

0:22:04.720,0:22:05.580  
比如对数的立方。

0:22:05.580,0:22:07.680  
Tracy：这让我想起了快速递归交互论证系统（FRI）。

0:22:07.680,0:22:12.300  
我们将通过进行 logn 轮工作来逐步减少工作量。

0:22:12.300,0:22:14.520  
Justin：是的。这也让人想起了 Bulletproofs。

0:22:14.520,0:22:19.280  
这是另一个演讲的主题，但 Bulletproofs 实际上就是 Sum-Check。

0:22:19.280,0:22:21.040  
所以如果你了解 Bulletproofs，你实际上已经了解了 Sum-Check，

0:22:21.040,0:22:23.100  
尽管你可能没有意识到你已经了解了。

0:22:23.100,0:22:23.780  
Tracy：好的。

0:22:23.780,0:22:24.960  
Justin：好的。

0:22:24.960,0:22:27.920  
所以我们处理的问题的规模

0:22:27.920,0:22:29.640  
在每一轮中都会减半。

0:22:29.640,0:22:33.520  
事实上，每一轮都会将问题分成两半，

0:22:33.520,0:22:37.920  
并通过两半的随机组合得到一个规模减半的问题实例。

0:22:37.920,0:22:38.800  
Tracy：太棒了。

0:22:38.800,0:22:39.280  
Justin：好的。

0:22:39.280,0:22:43.080  
所以在协议开始时，也就是第零轮，

0:22:43.080,0:22:48.560  
证明者会发送一个声称的答案 C₀。

0:22:48.560,0:22:52.000  
验证者会说，嘿，证明者，我不相信你是诚实的。

0:22:52.000,0:22:54.660  
向我证明你声称的答案是 C₀。

0:22:54.660,0:22:54.672  
Tracy：好的。

0:22:54.672,0:23:01.073  
Justin：证明者会说，好吧，我将这样向你证明。所以——

0:23:01.073,0:23:03.020  
Tracy：这里会有一个一致性检查，对吧？

0:23:03.020,0:23:07.880  
Justin：在证明者的第一轮消息（我稍后会定义）和这个声称的答案C₀之间，

0:23:07.880,0:23:11.280  
会有一个一致性检查。

0:23:11.280,0:23:14.600  
我会尽量别忘记一致性检查。

0:23:14.600,0:23:23.800  
所以证明者会发送一个一元多项式，

0:23:23.800,0:23:29.180  
我把它叫做 s₁，变量为大写的 X₁。

0:23:29.180,0:23:30.280  
Tracy：是的。

0:23:30.280,0:23:36.440  
Justin：如果证明者是诚实的，它将等于以下一元多项式。

0:23:37.160,0:23:39.800  
这个诚实的多项式，我称之为 h₁。

0:23:39.800,0:23:42.800  
但如果证明者在作弊，它可能会发送一个不等于 h₁ 的 s₁。

0:23:42.800,0:23:49.680  
h₁ 将被定义为项数略少的求和。

0:23:49.680,0:23:58.680  
我们现在要做的是，对除了第一个变量之外的所有变量求和。

0:23:58.680,0:24:04.400  
所以我们让第一个变量不参与求和，

0:24:04.400,0:24:06.360  
让它作为一个自由变量，

0:24:07.160,0:24:13.000  
但我们仍然会对最后 n-1 个变量的布尔值求和。

0:24:13.000,0:24:14.120  
Tracy：明白了。

0:24:14.120,0:24:14.840  
Justin：好的。

0:24:14.840,0:24:22.560  
现在，这个消息是专门设计的，如果证明者是诚实的，那么——

0:24:22.560,0:24:26.680  
你知道，如果 s₁ 等于 h₁，那么以下的等式将成立。

0:24:26.680,0:24:36.800  
如果 s₁ 等于它应该等于的值，那么声称的答案将等于

0:24:36.800,0:24:42.400  
或者真正的答案将等于 s₁(0) 加上 s₁(1)。对吧？

0:24:42.400,0:24:45.840  
因为我们定义 h₁ 时没有对第一个变量求和。

0:24:45.840,0:24:49.580  
如果你回过头来对第一个变量求和，你应该得到实际的答案。

0:24:49.580,0:24:50.880  
Tracy：明白了。

0:24:50.880,0:24:54.680  
Justin：再次强调，当我们说 Sum-Check 协议的每一轮

0:24:54.680,0:24:57.840  
是将涉及 2ⁿ 项的大问题实例分成两半，

0:24:57.840,0:25:01.880  
并对这两半进行随机线性组合，

0:25:01.880,0:25:03.280  
这两半就是这些。

0:25:03.280,0:25:10.440  
所以这涵盖了 x₁ 为 0 的项。

0:25:10.440,0:25:18.240  
对吧？如果你把 0 代入 h₁，那就像把第一个变量设为 0。

0:25:18.240,0:25:20.320  
如果你代入 1，那就像把第一个变量设为 1——

0:25:20.320,0:25:21.586  
所以这两半是——

0:25:21.586,0:25:22.872  
Tracy：所以你把项分成两半。我明白了。

0:25:22.872,0:25:24.320  
Justin：没错。

0:25:25.600,0:25:31.240  
现在来比较一下 Bulletproofs 或 FRI 可能更容易。

0:25:31.240,0:25:32.920  
不。对这两者来说都是。

0:25:33.440,0:25:35.800  
这就是 Sum-Check 的神奇之处。

0:25:35.800,0:25:42.560  
对于 FRI 或 Bulletproofs，你将大问题分成两半，

0:25:42.560,0:25:45.240  
证明者会对每一半进行加密承诺。

0:25:45.240,0:25:46.820  
在这里，没有承诺，也没有加密。

0:25:46.820,0:25:47.720  
Tracy：我明白了。

0:25:47.720,0:25:50.960  
Justin：这就是 Sum-Check 的惊人之处，

0:25:50.960,0:25:53.440  
也是它成为快速证明者 SNARK 的关键原因。

0:25:53.440,0:25:55.880  
Tracy：所以它不需要发送每一半的承诺。

0:25:55.880,0:25:57.920  
它发送什么来代替承诺？

0:25:57.920,0:26:00.833  
Justin：它只发送 s₁。明白吗？

0:26:00.833,0:26:02.440  
Tracy：这是一个低次多项式。

0:26:02.440,0:26:04.440  
Justin：次数非常低，并且只有一个变量。

0:26:04.440,0:26:10.440  
为了具体说明，假设 g 在每个变量中的次数是 2。

0:26:10.440,0:26:13.880  
在大多数应用中，g 的次数实际上是 3，

0:26:13.880,0:26:16.240  
有时是 2，有时比 3 稍高。

0:26:16.240,0:26:20.200  
但为了简单起见，假设每个变量的次数是 2。

0:26:21.320,0:26:27.840  
现在注意，一个次数为 2 的一元多项式只有三个系数。

0:26:29.320,0:26:33.480  
所以 s₁ 和 h₁，它们是次数为 2 的一元多项式。

0:26:33.480,0:26:36.120  
所以证明者只发送 s ——实际上只是 3 个域元素。

0:26:36.120,0:26:39.520  
实际上，你甚至不需要证明者发送所有三个域元素，

0:26:39.520,0:26:46.400  
因为只有当 s₁(1) = C₀ - s₁(0) 时，这个检查才会通过。

0:26:46.400,0:26:49.240  
所以你甚至不需要证明者发送（全部元素）。

0:26:49.240,0:26:50.960  
你可以通过从这个检查过程中推断出一个自由度，

0:26:50.960,0:26:55.347  
从而减少一个域元素。

0:26:55.347,0:26:55.480  
Tracy：我明白了。

0:26:55.480,0:26:57.120  
Justin：如果不是这样，检查就会失败。

0:26:57.120,0:27:00.600  
所以现在假设它通过了。

0:27:00.600,0:27:03.800  
所以每一轮的消息非常非常小。

0:27:03.800,0:27:05.400  
而且每一轮对应一个变量。

0:27:05.400,0:27:09.200  
所以经过优化后，总证明规模大约是

0:27:09.840,0:27:13.720  
电路规模的对数乘以 2，或者类似数量的域元素。

0:27:13.720,0:27:15.120  
Tracy：我明白了。

0:27:15.120,0:27:17.560  
所以每一轮你会传递 2 个域元素，

0:27:17.560,0:27:18.920  
然后可以进行求值，

0:27:18.920,0:27:21.080  
然后你会重复这个过程进行 logn 轮？

0:27:21.080,0:27:22.480  
Justin：对。完全正确。

0:27:22.480,0:27:27.360  
现在的问题是，目前我只告诉了你第一轮的消息。

0:27:27.360,0:27:29.140  
所以我们为什么还没完成呢？对吧？

0:27:29.140,0:27:29.152  
Tracy：是的。

0:27:29.152,0:27:33.400  
Justin：问题是验证者实际上并不知道 h₁ 是什么。对吧？

0:27:33.400,0:27:35.400  
它是通过一个相当大的求和定义的，

0:27:35.400,0:27:39.040  
这个求和大约是原始求和的一半大小，但仍然很大。

0:27:39.040,0:27:40.000  
Tracy：是的。

0:27:40.000,0:27:42.820  
Justin：所以验证者实际上并不知道 s₁ 是否等于 h₁。

0:27:42.820,0:27:43.560  
Tracy：是的。

0:27:43.560,0:27:44.840  
Justin：是的。

0:27:44.840,0:27:50.553  
这就是下一轮的目的。所以——

0:27:50.553,0:27:54.960  
Tracy：它检查了一个约束条件，但还没有检查所有的 h₁。

0:27:54.960,0:27:55.840  
Justin：没错。

0:27:56.720,0:28:00.080  
所以一致性检查，我得确保不要忘记，

0:28:00.080,0:28:02.360  
是证明者发送 s₁ 后，

0:28:02.360,0:28:13.120  
验证者检查 s₁(0) + s₁(1) 是否确实等于声称的答案。

0:28:13.120,0:28:15.640  
这是在问这两部分

0:28:15.640,0:28:20.040  
是否与最初声称的单一答案一致。

0:28:20.560,0:28:24.560  
然后验证者需要检查这两部分是否诚实？

0:28:24.560,0:28:27.720  
也就是说，s₁ 是否真的等于 h₁？

0:28:27.720,0:28:28.220  
好的。

0:28:33.560,0:28:36.520  
现在证明者明确地将 s₁ 发送给了验证者。

0:28:36.520,0:28:38.720  
它只是三个系数。

0:28:39.640,0:28:44.800  
所以验证者实际上知道 s₁。但验证者并不知道 h₁。

0:28:44.800,0:28:45.310  
Tracy：对。

0:28:50.240  
Justin：好的。那么验证者在不知道 h₁ 的情况下如何检查呢？

0:28:50.240,0:28:54.080  
让我把事情简化一下，尽管这还不是全部。

0:28:54.080,0:29:01.200  
验证者将随机选择一个域元素，一个 s₁ 的随机输入，

0:29:01.200,0:29:06.660  
将这个域元素，我称之为 r₁，发送给证明者。

0:29:06.660,0:29:10.040  
Tracy：并要求它在 r₁ 处对 h₁进行求值。

0:29:10.040,0:29:12.720  
Justin：对。对。然后，你知道——

0:29:12.720,0:29:15.720  
现在验证者想要确认——

0:29:15.720,0:29:23.320  
这就是第二轮的目标，即 s₁(r₁) = h₁(r₁)。

0:29:23.320,0:29:26.240  
现在，验证者可以自己计算 s₁(r₁)。它知道 s₁。

0:29:26.240,0:29:28.120  
但它不知道 h₁(r₁)。

0:29:28.120,0:29:33.380  
所以它将使用 Sum-Check 的第二轮来计算 h₁(r₁)。

0:29:33.380,0:29:37.600  
Tracy：这样做是为了让验证者确认

0:29:37.600,0:29:42.600  
这个 s₁ 是整个大问题的一元多项式。

0:29:42.600,0:29:47.040  
Justin：它让证明者确认 s₁ 实际上等于它应该等于的 h₁。

0:29:47.040,0:29:48.320  
如果它确实等于它应该等于的值，

0:29:48.320,0:29:51.660  
那么通过一致性检查，声称的答案确实是正确的。

0:29:51.660,0:29:53.640  
Tracy：我明白了。

0:29:53.640,0:29:54.720  
好的。

0:29:54.720,0:29:55.960  
Justin：是的。这——

0:29:55.960,0:29:57.760  
你知道，有一种方式可以将其形象化为——

0:29:57.760,0:30:00.760  
我们将求和分成两半。

0:30:00.760,0:30:03.520  
前半部分是第一个变量固定为 0，

0:30:03.520,0:30:05.800  
后半部分是第一个变量固定为 1。

0:30:05.800,0:30:10.160  
将第一个变量固定为 r₁

0:30:10.160,0:30:13.320  
就像对两半进行随机线性组合。

0:30:13.320,0:30:15.980  
然后将两半合并成一个。

0:30:15.980,0:30:16.880  
Tracy：将它们折叠在一起。

0:30:16.880,0:30:18.640  
Justin：是的。将它们折叠在一起。

0:30:18.640,0:30:24.280  
这里的关键点是 h₁(r₁) 是——

0:30:24.280,0:30:26.720  
我把 r₁ 代入这里。对吧？

0:30:26.720,0:30:28.040  
是——

0:30:29.080,0:30:32.480  
这正是我们设计 Sum-Check 来证明的那种陈述，

0:30:32.480,0:30:36.040  
只不过现在我们将其应用于少一个变量的多项式。

0:30:36.040,0:30:44.600  
所以不是将 Sum-Check 应用于 G 本身，而是将其应用于多项式——

0:30:44.600,0:30:45.480  
我将其称之为，我想想，

0:30:45.480,0:30:54.240  
从 g 中得到 g*，从 x₂ 到 xₙ，通过将第一个变量固定为 r₁ 。

0:30:54.240,0:30:57.040  
Tracy：对。你把问题简化了一些。

0:30:57.040,0:30:58.160  
Justin：是的。完全正确。

0:30:58.160,0:31:03.520  
所以你一轮一轮地这样做，然后在——

0:31:03.520,0:31:08.920  
在一轮之后，变量1 被固定为 r₁。

0:31:08.920,0:31:13.920  
所以证明者在证明 h₁(r₁) 的值，

0:31:14.440,0:31:18.080  
记住，这就像 g(r₁) 加上其他变量。

0:31:18.080,0:31:22.880  
在第二轮之后，证明者做出关于 h₂(r₂) 的声明，

0:31:22.880,0:31:28.080  
这将是 g 的第一个变量固定为 r₁，第二个变量固定为 r₂。

0:31:28.080,0:31:31.840  
最终你会进行到第 n 轮，每一轮对应一个变量。

0:31:31.840,0:31:36.920  
在那轮结束时，证明者做出关于 g 所有变量都固定时的声明。

0:31:36.920,0:31:41.520  
这个声明，验证者将自行计算，

0:31:41.520,0:31:46.880  
因为我们说过 Sum-Check 的整个目的是将，

0:31:46.880,0:31:51.080  
涉及g的2ⁿ次求值的原始声明，减少为在单个点上对 g 进行求值。

0:31:51.080,0:31:51.700  
我们已经做到了。

0:31:51.700,0:31:52.240  
Tracy：明白了。

0:31:52.240,0:31:53.680  
Justin：但现在我们需要讨论的是，

0:31:53.680,0:31:58.160  
在应用中，验证者是否真的能快速得到那个单点求值？

0:31:58.160,0:32:00.760  
这可能会有所不同。我们会进一步讨论这个问题。

0:32:00.760,0:32:05.520  
Tracy：好的。很酷。看看这如何映射到 R1CS，

0:32:05.520,0:32:07.320  
比如某种约束系统，可能会很有用。

0:32:07.320,0:32:08.920  
Justin：很好。

0:32:08.920,0:32:13.560  
所以这实际上是我想要介绍的第一个应用。

0:32:14.720,0:32:17.600  
我们还会让协议中的内容，

0:32:17.600,0:32:19.840  
我认为，更加具体。

0:32:20.960,0:32:23.160  
让我暂时把这个留在这里——

0:32:23.160,0:32:24.040  
实际上，让——

0:32:24.040,0:32:26.860  
我把目标留在这里。去掉其他所有内容。

0:32:26.860,0:32:27.840  
Tracy：听起来不错。

0:32:29.160,0:32:30.880  
Justin：好的。

0:32:30.880,0:32:33.240  
也许我会从图示开始，然后，

0:32:33.920,0:32:35.640  
在在更正式地讲解之前。

0:32:35.640,0:32:42.520  
所以在 R1CS 中，有三个矩阵，证明者和验证者都知道。

0:32:42.520,0:32:48.360  
它们被称为约束矩阵，分别称为 A、B 和 C。

0:32:48.360,0:32:49.120  
好的。

0:32:49.680,0:32:51.200  
然后——

0:32:51.200,0:32:52.520  
所以这些是矩阵。

0:32:52.520,0:32:59.360  
所以也许我会说它们有 M 行和 N 列。

0:32:59.360,0:33:00.480  
Tracy：对。

0:33:00.480,0:33:11.040  
Justin：证明者声称知道一个 z，使得 (Az)——

0:33:11.040,0:33:17.340  
这是矩阵-向量乘积，逐项乘积 (Bz) 等于 (Cz) 。

0:33:17.340,0:33:18.440  
Tracy：是的。

0:33:18.440,0:33:18.920  
Justin：好的。

0:33:18.920,0:33:23.480  
现在我要给这些矩阵-向量乘积起个名字。

0:33:23.480,0:33:27.040  
让我们称它们为 小a、小b 和 小c。

0:33:27.040,0:33:27.760  
Tracy：好的。

0:33:27.760,0:33:28.280  
Justin：好的。

0:33:28.280,0:33:36.880  
所以声明是，对于每个约束条件，也就是这些矩阵的每一行。

0:33:36.880,0:33:41.360  
Tracy：这实际上是在针对给定的见证，

0:33:41.360,0:33:45.060  
评估SNARK的约束，并确定所有约束条件都为0。

0:33:45.060,0:33:45.489  
Justin：是的。

0:33:45.489,0:33:47.920  
Tracy：所有约束。  
Justin：所以，你可以把 z 大致看作是，

0:33:47.920,0:33:50.980  
SNARK证明者声称所知道的见证。

0:33:50.980,0:33:50.992  
Tracy：对。

0:33:50.992,0:33:56.920  
Justin：这些矩阵的每一行共同构成一个约束条件。

0:33:56.920,0:34:01.320  
所以证明者声称知道一个z， 满足所有 M 个约束条件。

0:34:01.320,0:34:03.680  
这个大写的 N 就类似于见证的大小，

0:34:03.680,0:34:05.360  
这个大写的 M 是约束的数量。

0:34:05.360,0:34:05.860  
Tracy：对。

0:34:06.120,0:34:06.620  
Justin：好的。

0:34:06.620,0:34:09.120  
所以这个声明是，对于每一个——

0:34:09.120,0:34:11.600  
每个约束的形式是 aᵢ——

0:34:11.600,0:34:15.560  
小aᵢ 乘以 小bᵢ 等于 小cᵢ。
 
0:34:15.560,0:34:19.040  
所以声明是，对于每一个条目，

0:34:21.000,0:34:24.660  
这个条目乘以这个条目减去这个条目等于零。

0:34:24.660,0:34:25.600  
Tracy：等于零。是的。

0:34:25.600,0:34:27.080  
Justin：好的。

0:34:27.080,0:34:29.480  
所以你需要做一些思维转换。

0:34:29.480,0:34:34.040  
比如，与其把 a 看作一个长度为 m 的向量，

0:34:34.040,0:34:38.320  
我们想把它看作一个定义域为 {0,1}^logm 的函数。

0:34:38.320,0:34:39.060  
Tracy：是的。

0:34:39.060,0:34:41.360  
Justin：好的。这是一个非常自然的做法，

0:34:41.360,0:34:46.640  
我们不是用 0 到 m-1 的整数来索引 a 的元素，

0:34:46.640,0:34:48.440  
我们用位向量来索引它们，

0:34:48.440,0:34:50.980  
也就是整数的二进制表示。

0:34:50.980,0:34:51.920  
Tracy：是的。  
Justin：所以现在我们要——

0:34:51.920,0:34:59.760  
所以我们把 a 看作一个定义域为 {0,1}^logm 的函数。

0:34:59.760,0:35:03.680  
Tracy：所以如果看所有位向量的组合，

0:35:03.680,0:35:06.580  
你可以从中选择任何一个给定的约束。

0:35:06.580,0:35:07.520  
Justin：没错。

0:35:07.520,0:35:12.960  
举一个大小为 4 的具体例子，

0:35:13.480,0:35:23.513  
如果这是 a，我们有a(0,0) = 2，  
a(0,1) = 3，a(1,0) = 4，a(1,1) = 5。

0:35:23.513,0:35:24.160  
Tracy：对。

0:35:24.160,0:35:25.040  
Justin：对吧？

0:35:25.040,0:35:28.420  
我们只是用位向量而不是整数来索引 a 的条目。

0:35:28.420,0:35:30.840  
Tracy：是的。所以这是长度为 2ⁿ 的，

0:35:30.840,0:35:34.200  
因此你有两个条目来索引所有内容。

0:35:34.200,0:35:34.600  
是的。

0:35:34.600,0:35:35.520  
Justin：是的。完全正确。

0:35:35.520,0:35:37.520  
所以，是的，这个大小是 M（大写），

0:35:37.520,0:35:43.680  
我们现在输入到 a 的变量数是它的对数。

0:35:43.680,0:35:44.560  
Tracy：是的。

0:35:44.560,0:35:45.840  
Justin：很好。

0:35:45.840,0:35:51.080  
现在关于定义在 {0,1}^任意值 上的函数的美妙之处在于，

0:35:51.080,0:35:53.680  
它们总是有一个唯一的多线性扩展。

0:35:53.680,0:35:59.300  
所以如果我在 a 上加一个波浪号，我们现在讨论的是它的多线性扩展多项式。

0:35:59.300,0:35:59.312  
Tracy：是的。

0:35:59.312,0:36:04.920  
Justin：好的。所以如果你想要一个基于 Sum-Check 的用于 R1CS 的SNARK，

0:36:04.920,0:36:07.120  
有一个叫做 Spartan 的协议，

0:36:08.400,0:36:11.040  
本质上，第一个 Sum-Check 应用于一个多项式，

0:36:11.040,0:36:13.960  
我稍后会告诉你它是什么，

0:36:14.680,0:36:20.520  
它正好体现了这里的这个等式关系，

0:36:20.520,0:36:24.200  
但是，你知道，它用它们的多线性扩展替换了 a、b 和 c，

0:36:24.200,0:36:28.200  
因为 Sum-Check 需要应用于多元多项式。

0:36:28.200,0:36:31.300  
Tracy：所以你做了一个转换，得到多线性扩展？

0:36:31.300,0:36:31.960  
Justin：对。

0:36:31.960,0:36:33.820  
Tracy：然后你可以用 Sum-Check 对其进行求值。

0:36:33.820,0:36:34.720  
Justin：对。

0:36:34.720,0:36:37.120  
所以从概念上讲，Sum-Check 中会发生的是，

0:36:37.120,0:36:42.080  
第一轮会将 a、b 和 c 分成两半，

0:36:42.680,0:36:47.000  
并确保这两半与

0:36:47.000,0:36:49.440  
所声称的右边为零保持一致。

0:36:49.440,0:36:51.680  
然后将两半合并在一起。

0:36:51.680,0:36:55.240  
所以第二轮，你会得到三个长度减半的向量。

0:36:55.240,0:36:56.153  
然后第二轮——

0:36:56.153,0:36:58.600  
Tracy：你通过固定其中一个变量来实现这一点。

0:36:58.600,0:36:59.200  
Justin：是的。

0:37:00.440,0:37:02.480  
固定为一个随机值。完全正确。

0:37:02.480,0:37:03.280  
就是这样。

0:37:03.280,0:37:07.440  
再次强调，Sum-Check 相对于目前更流行的许多 SNARK 的优势在于，

0:37:07.440,0:37:10.680  
Sum-Check 本身没有承诺成本。

0:37:10.680,0:37:13.280  
证明者只是对域元素进行加和乘运算。

0:37:13.280,0:37:18.040  
所以如果你比较——

0:37:18.040,0:37:19.120  
比如 Marlin 是一个不使用多元多项式的 SNARK，

0:37:19.120,0:37:23.840  
它用于 R1CS，使用的是一元多项式。

0:37:23.840,0:37:27.040  
所以它——

0:37:27.040,0:37:27.400  
它能非常清晰地映射到我们在这里讨论的相同设置中。

0:37:27.400,0:37:33.360  
Marlin 要做的第一件事就是让证明者对这些向量 a、b 和 c 进行承诺。

0:37:33.360,0:37:38.480  
Tracy：是的。

0:37:38.480,0:37:38.960  
所以你必须遍历所有 n 项来进行承诺。对吧？

0:37:38.960,0:37:42.060  
Justin：对。

0:37:42.060,0:37:48.520  
对数据进行承诺的成本很高，而且具体代价因情况而异。

0:37:48.520,0:37:52.080  
所以如果你不必进行承诺，那通常是一件好事。

0:37:52.080,0:37:55.280  
Tracy：我想其中一个区别是，一旦你进行了承诺，

0:37:55.280,0:37:57.440  
验证者的工作可以是常数时间。

0:37:57.440,0:37:58.360  
Justin：对。

0:37:58.360,0:38:01.747  
Tracy：而在 Sum-Check 中，验证者要做 logn 的工作量。

0:38:01.747,0:38:02.600  
Justin：对。是的。

0:38:02.600,0:38:08.720  
是的。所以如果你真的想要常数大小的证明，那你确实不能使用 Sum-Check。

0:38:08.720,0:38:10.338  
你总是会得到对数级的工作量。

0:38:10.338,0:38:10.560  
Tracy：明白了。  
Justin：好的。

0:38:10.560,0:38:13.160  
但如果你打算使用基于哈希的承诺方案（如 FRI 之类），

0:38:13.160,0:38:16.080  
来获得多项式对数大小的证明

0:38:16.080,0:38:17.520  
无论如何你都会有多项式对数级的工作量。

0:38:17.520,0:38:19.307  
这个对数级其实影响不大。T

0:38:19.307,0:38:19.320  
racy：对。

0:38:19.320,0:38:22.060  
而且这样比必须对所有信息进行承诺更高效。

0:38:22.060,0:38:23.000  
Justin：对，对。

0:38:23.000,0:38:25.360  
而且你不需要检查已承诺的数据，

0:38:25.360,0:38:26.960  
你知道，承诺的数据越多——

0:38:26.960,0:38:28.240  
任何承诺的数据，

0:38:28.240,0:38:32.440  
你最终都需要证明承诺中的数据是“合规”的。

0:38:32.440,0:38:33.680  
所以不仅仅是承诺数据，

0:38:33.680,0:38:37.320  
你还需要证明所有这些额外的承诺数据是“合规”的。

0:38:37.320,0:38:38.360  
Tracy：对。

0:38:38.360,0:38:41.240  
Justin：是的。另一个好处是，

0:38:41.240,0:38:46.480  
避免使用多元多项式而只使用一元多项式的 SNARK，

0:38:47.000,0:38:52.600  
在协议中通常有一个所谓的“商多项式”。

0:38:53.320,0:38:58.440  
这个商多项式，如果你是证明者的话，

0:38:58.440,0:39:01.600  
你可能需要显式计算它。

0:39:01.600,0:39:03.200  
但在 Sum-Check中，就不存在——

0:39:03.200,0:39:07.200  
不存在商多项式。你只进行求和，

0:39:07.200,0:39:10.600  
即使你不计算商多项式，

0:39:10.600,0:39:14.760  
即使你不进行承诺，商多项式的值

0:39:14.760,0:39:16.760  
你基本上也无法控制。

0:39:16.760,0:39:19.960  
所以即使 a、b 和c 中的所有条目都很小，

0:39:19.960,0:39:23.360  
一旦涉及到商多项式，商多项式的值就会变得很大。

0:39:23.360,0:39:28.000  
所以，是的，如果你使用这种多元多项式的方法，

0:39:28.000,0:39:32.200  
你会减少承诺的次数和除法运算，并且值也更小。

0:39:32.200,0:39:33.632  
Tracy：好的。

0:39:33.632,0:39:37.140  
Justin：所以总结一下，正式地讲，发生了什么——

0:39:37.140,0:39:37.680  
所以这是——

0:39:37.680,0:39:42.760  
我大概勾勒了一下类似 Spartan 这种 SNARK 的多项式 IOP（交互式 Oracle 证明）。

0:39:42.760,0:39:44.120  
我简单说一下——

0:39:44.120,0:39:47.920  
这就是为什么我在这次演讲的第一部分介绍了这个等式多项式。

0:39:47.920,0:39:52.920  
所以我只需要一个关于多项式的基本事实，如下所示。

0:39:54.240,0:40:00.320  
设 g(x) 是任意 n 元多项式，

0:40:00.320,0:40:12.760  
设 p(x) 是唯一的多线性多项式，

0:40:14.360,0:40:16.720  
比如说——

0:40:16.720,0:40:17.680  
我就这样写吧。

0:40:17.680,0:40:24.600  
不一定是多线性的。

0:40:24.600,0:40:27.320  
先明确这一点。

0:40:28.600,0:40:47.720  
好的。设 p(x) 是唯一的满足这个条件的多线性多项式，

0:40:47.720,0:40:49.000  
你知道，与 g 一致的那个。

0:40:49.000,0:40:54.880  
也就是说，在布尔输入上具有相同的输入输出行为。

0:40:54.880,0:40:57.839  
记住，我给出的任何的在布尔超立方体上的输入输出行为，

0:40:57.839,0:41:00.872  
都有一个唯一的多线性多项式具有这种行为。

0:41:04.851,0:41:05.697  
明白吗？

0:41:05.697,0:41:14.777  
然后我们可以将 p 表示为 p(r)。

0:41:15.080,0:41:27.240  
你知道，r 中有 n 个变量， 

0:41:27.800,0:41:33.680  
对 eq(x,r) * g(x) 的 x 在{0,1}ⁿ 范围上的求和。

0:41:33.680,0:41:34.200  
明白吗？

0:41:34.200,0:41:38.440  
所以检查这个等式是否成立的方法是，

0:41:38.440,0:41:41.480  
我们之前定义等式多项式时做过一次。

0:41:41.480,0:41:45.160  
你需要确保右边是多线性的，

0:41:45.160,0:41:48.360  
并且它在任何布尔值的 r，即只取 0 或 1 坐标的 r 上

0:41:48.360,0:41:51.240  
与 g 一致。

0:41:51.240,0:41:51.960  
Tracy：好的。

0:41:51.960,0:41:52.600  
Justin：好的。

0:41:52.600,0:41:56.120  
实际情况是，它显然是多线性的，因为

0:41:56.120,0:42:00.900  
我们只将 r 输入到这个等式多项式中，而它被定义为多线性的。

0:42:00.900,0:42:00.912  
Tracy：是的。

0:42:00.912,0:42:04.120  
Justin：然后要理解它的输入输出行为，对吧？

0:42:04.120,0:42:10.080  
如果 r 的坐标仅为 0 或 1，eq的关键在于，

0:42:10.080,0:42:15.520  
你在对所有的布尔输入求和，但其中只有一个输入会等于 r。

0:42:15.520,0:42:17.960  
所以除了我们关心的那一项，求和中的每一项都会消失，

0:42:17.960,0:42:20.940  
然后就得到了 g 在那一项上的输出。

0:42:20.940,0:42:20.952  
Tracy：是的。

0:42:20.952,0:42:23.920  
Justin：好的。所以这是一种多线性化表达式，

0:42:23.920,0:42:30.700  
其中g可能不是多线性的，但通过看这个式子我可以把它当作是多线性的。

0:42:30.700,0:42:34.760  
Tracy：对。通过提取 g 的一部分并将其他部分归零。

0:42:34.760,0:42:36.160  
Justin：是的。类似这样。

0:42:36.160,0:42:37.760  
这有点像——

0:42:37.760,0:42:39.880  
如果 r 是随机选择的——

0:42:39.880,0:42:42.440  
所以最终验证者会在某个地方随机选择 r。

0:42:42.440,0:42:43.800  
Tracy：我明白了。

0:42:43.800,0:42:46.240  
Justin：然后这就像——

0:42:46.240,0:42:49.920  
它就像对超立方体上的 g 的求值进行求和，

0:42:49.920,0:42:52.480  
但每一项都乘以某个奇怪的项。

0:42:52.480,0:42:54.680  
也就是说，如果——

0:42:54.680,0:43:03.480  
是的，这就是你如何以这种方式消除 g 的非多线性部分。

0:43:03.480,0:43:04.320  
Tracy：好的。

0:43:04.320,0:43:09.640  
Justin：所以，Spartan 的工作原理就像我之前告诉你的那样，

0:43:09.640,0:43:16.040  
你对 a、b 和 c 进行一轮又一轮的折叠，每次将它们减半。

0:43:16.040,0:43:19.680  
但现在我要告诉你——我们实际上——

0:43:19.680,0:43:22.200  
我们将 Sum-Check 应用于哪个多项式？

0:43:22.200,0:43:24.480  
是的。所以我们刚刚讨论了这个事实，

0:43:24.480,0:43:29.920  
它让我们能够将在布尔输入上与 g 一致的唯一的多线性多项式的求值。

0:43:29.920,0:43:36.440  
表示为 g 的求值的一个很好的求和。

0:43:36.440,0:43:36.800  
好的。

0:43:36.800,0:43:40.560  
而这样的求和正是设计 Sum-Check 协议用来计算的。

0:43:40.560,0:43:44.040  
所以我很高兴我们能够以这种形式，

0:43:44.040,0:43:46.580  
用 g 的求值来描述 p 的求值，。

0:43:46.580,0:43:47.080  
Tracy：对。

0:43:47.080,0:43:47.440  
Justin：好的。

0:43:47.440,0:43:52.040  
那我们回到 Spartan，确切地说，它对什么应用了 Sum-Check 协议？

0:43:52.040,0:43:56.800  
在 Spartan 中，我们最终关心的多项式 g 是

0:43:56.800,0:44:00.200  
a 的多线性扩展乘以 b 的多线性扩展

0:44:00.200,0:44:03.320  
减去 c 的多线性扩展。

0:44:03.320,0:44:05.080  
好的。所以证明者声称——

0:44:05.080,0:44:09.360  
当证明者说 R1CS 约束都满足时，

0:44:09.360,0:44:21.120  
这等于说对于所有 x∈{0,1}^logm，g(x)=0。

0:44:21.120,0:44:21.720  
对吧？

0:44:21.720,0:44:24.040  
你知道，这里每个 x 就是对一个约束条件进行索引。

0:44:24.040,0:44:26.880  
这表示第 x 个约束是满足的。

0:44:26.880,0:44:33.620  
对。但由于这里的乘法运算，g 不是多线性的。

0:44:33.620,0:44:34.592  
Tracy：是的。我明白了。

0:44:34.592,0:44:35.400  
Justin：好的。

0:44:35.400,0:44:43.600  
现在我们再稍微停顿一下，观察一下，如果 g 是多线性的，

0:44:43.600,0:44:47.240  
它不是，但假设它是多线性的，

0:44:47.240,0:44:57.040  
那么这个声明就等价于 g 是零多项式。

0:44:58.320,0:45:02.080  
因为零多项式是多线性的，

0:45:03.160,0:45:07.720  
并且它在布尔超立方体上的所有点上都有这样的性质。

0:45:07.720,0:45:09.560  
这是唯一的。

0:45:09.560,0:45:10.640  
Tracy：对。

0:45:10.640,0:45:11.320  
Justin：好的。

0:45:11.320,0:45:11.633  
所以——

0:45:11.633,0:45:15.200  
Tracy：所以这是你之前解释的使用等式多线性的技巧。

0:45:15.200,0:45:15.960  
Justin：没错。

0:45:15.960,0:45:19.640  
所以如果g是多线性的，验证者只需随机选择一个点，

0:45:19.640,0:45:21.360  
在该点对 g 进行求值。

0:45:21.360,0:45:23.880  
你知道，如果证明者是诚实的，它会输出 0。

0:45:23.880,0:45:27.240  
如果证明者不诚实，那么 g 就不会是零多项式，

0:45:27.240,0:45:29.520  
它不会以压倒性的概率输出0。

0:45:29.520,0:45:33.200  
问题是 g 不是多线性的。这就是该方法的目的。

0:45:33.200,0:45:34.680  
好的。这就是 Spartan的情况。

0:45:34.680,0:45:41.640  
所以 V 随机地 从 logm 的域中选择 r。
 
0:45:41.640,0:45:43.680  
然后把 r 发送给证明者。

0:45:43.680,0:45:45.000  
Tracy：对。

0:45:45.000,0:45:45.680  
Justin：好的。

0:45:45.680,0:45:50.280  
然后他们应用 Sum-Check。也许是 r——或者就是 r。

0:45:50.280,0:45:59.440  
对，应用 Sum-Check 来确认 p(r)=0。

0:45:59.440,0:46:02.000  
p(r) 是什么呢？

0:46:02.000,0:46:05.800  
它是求和——

0:46:05.800,0:46:14.960  
就在那里。对 {0,1}^logm 中的 x，对 (eq) ̃  (x,r), g(x)求和。

0:46:14.960,0:46:17.040  
好的。然后——

0:46:17.040,0:46:19.720  
很好。这就是 Spartan 的做法。

0:46:19.720,0:46:20.520  
Tracy：太棒了。

0:46:20.520,0:46:22.160  
Justin：现在，在这个 Sum-Check 结束时，

0:46:22.160,0:46:26.320  
验证者必须在随机点上对这个多项式进行求值。

0:46:26.320,0:46:28.400  
这需要在随机点上对 g 求值。

0:46:28.400,0:46:28.960  
Tracy：是的。

0:46:28.960,0:46:31.840  
Justin：好的。现在这有点麻烦，

0:46:31.840,0:46:35.339  
因为验证者不知道 a、b 和 c （小写）是什么。

0:46:35.339,0:46:35.480  
Tracy：对。  
Justin：好的。

0:46:35.480,0:46:40.360  
但事实证明，你可以通过第二次 Sum-Check

0:46:40.360,0:46:42.613  
得到对这些中的每一个你所需要的单次求值。

0:46:42.613,0:46:42.920  
Tracy：有意思。  
Justin：好的。

0:46:42.920,0:46:44.360  
在第二次 Sum-Check 结束时，

0:46:44.360,0:46:48.240  
验证者最终只需要在随机点上对 z 求值。

0:46:48.240,0:46:52.600  
而这个 z 在协议开始时就已经通过一种方案进行了承诺，

0:46:52.600,0:46:56.020  
这种方案使得可以从承诺方案中得到求值。

0:46:56.020,0:46:57.320  
Tracy：我明白了。

0:46:57.320,0:46:59.600  
Justin：所以，是的，Spartan 的好处是，

0:46:59.600,0:47:03.240  
相对于不使用 Sum-Check、只使用一元多项式的 SNARK，

0:47:03.240,0:47:05.680  
只有 z 被承诺。

0:47:05.680,0:47:07.800  
而不是小a、小b、小c。

0:47:07.800,0:47:09.120  
也没有商多项式。

0:47:09.120,0:47:13.460  
Tracy：你承诺的是见证，但不需要承诺整个电路。

0:47:13.460,0:47:14.240  
Justin：是的。

0:47:14.240,0:47:17.800  
比如不是每个约束条件的值，而只是对见证进行承诺。

0:47:17.800,0:47:19.680  
差不多是这样。

0:47:19.680,0:47:20.120  
是的。

0:47:20.120,0:47:22.360  
Tracy：这减少了证明者的工作。

0:47:22.360,0:47:23.200  
Justin：是的。

0:47:23.200,0:47:25.920  
事实上，现在已知在 Sum-Check 中，

0:47:25.920,0:47:31.880  
证明者的工作量可以降到 5m 次域操作。

0:47:31.880,0:47:33.900  
这个 5 非常小。

0:47:33.900,0:47:36.080  
Tracy：是的。  
Justin：没有其他方法能与之匹敌。

0:47:36.080,0:47:39.760  
所以它使用了一些非常新的优化，

0:47:39.760,0:47:43.040  
但即使在那之前，它也是 10m 左右。

0:47:43.040,0:47:45.280  
所以，对于今天使用的大多数SNARK来说

0:47:45.280,0:47:51.520  
5m个域操作相几乎可以忽略不计。

0:47:52.080,0:47:53.280  
是的。这就是 Spartan。

0:47:53.280,0:47:56.520  
Tracy：很酷。我想我们接下来会讨论一下 GKR，

0:47:56.520,0:47:59.840  
也许对比一下这些技术——

0:47:59.840,0:48:02.600  
特别是把这种技术与现有的一些其他的 SNARK 技术进行对比。

0:48:02.600,0:48:03.680  
Justin：是的。完全正确。

0:48:03.680,0:48:09.240  
所以 Spartan 是一个基于 Sum-Check 的 SNARK，而 GKR 是——

0:48:09.240,0:48:11.640  
实际上，它是一个使用 Sum-Check 协议的交互式证明，

0:48:11.640,0:48:15.000  
你可以通过将其与承诺方案结合，来将其转化为 SNARK。

0:48:15.000,0:48:15.760  
Tracy：好的。

0:48:15.760,0:48:19.920  
Justin：我认为对比这两者是有启发性的，

0:48:21.160,0:48:26.400  
因为 GKR 在某种程度上将 Sum-Check 的理念推向了极致，

0:48:26.400,0:48:30.400  
真的最大程度低减少了被承诺的数据量。

0:48:30.400,0:48:36.160  
这在某些应用中非常强大，但在其他应用中可能会带来一些缺点。

0:48:36.160,0:48:37.520  
所以我们可以稍微讨论一下。

0:48:37.520,0:48:38.100  
Tracy：好的。

0:48:38.680,0:48:40.440  
Justin：好的。

0:48:42.200,0:48:45.160  
GKR 协议，

0:48:45.160,0:48:50.320  
由 Goldwasser、Kalai 和 Rothblum在 2008 年提出，以他们的名字命名

0:48:51.040,0:48:56.400  
在电路，而不是 R1CS 的上下文中来描述会更合适。

0:48:56.400,0:49:01.480  
电路的输入是域元素，

0:49:01.480,0:49:08.280  
电路的每个门将两个域元素相加或相乘。

0:49:08.280,0:49:08.820  
Tracy：是的。

0:49:08.820,0:49:09.455  
Justin：好的。

0:49:09.455,0:49:11.611  
Tracy：它更像 Plonk 而不是 R1CS。

0:49:11.611,0:49:15.560  
Justin：没错。Plonk 最初也是针对电路描述的。

0:49:16.240,0:49:23.080  
我们之前在 R1CS 的情境下介绍了 Spartan，如果将其应用于电路，

0:49:23.080,0:49:25.720  
其实也可以自然地将其应用于电路中。

0:49:25.720,0:49:29.280  
事实上，这基本上是一个早期的叫做Clover的工作。

0:49:29.280,0:49:31.080  
证明者要做的第一件事是

0:49:31.080,0:49:34.395  
对电路中每个门的值进行加密承诺。

0:49:34.752,0:49:35.540  
Tracy：我明白了。

0:49:35.540,0:49:40.440  
Justin：好的。Spartan 只有两次 Sum-Check。

0:49:40.440,0:49:40.640  
好的。

0:49:40.640,0:49:46.480  
实际上，在像 Jolt 这样的应用中，你只需要一次 Sum-Check。

0:49:46.480,0:49:49.240  
所以它有点像一次性证明整个电路。

0:49:49.240,0:49:49.840  
Tracy：是的。

0:49:49.840,0:49:50.440  
Justin：好的。

0:49:50.440,0:49:56.640  
在 GKR 协议中，证明者从不承诺任何东西。

0:49:57.520,0:50:03.080  
验证者最终需要在随机点上评估电路的输入。

0:50:03.080,0:50:04.720  
这是多线性扩展。

0:50:04.720,0:50:08.560  
所以如果验证者知道 x，即电路的输入，

0:50:08.560,0:50:10.640  
GKR 协议中不涉及加密技术。

0:50:10.640,0:50:11.280  
Tracy：明白了。

0:50:11.280,0:50:13.640  
Justin：这是一个交互式证明。

0:50:13.640,0:50:15.200  
不需要对任何东西进行承诺。

0:50:15.200,0:50:16.540  
它在信息理论上是可靠的。

0:50:16.540,0:50:20.240  
Tracy：对。所以与 FRI 或 KZG 相比，
 
0:50:20.240,0:50:25.040  
两者都依赖于不同的加密结构进行加密承诺。

0:50:25.040,0:50:26.000  
Justin：对。

0:50:26.000,0:50:30.600  
所以，你知道，任何 SNARK 通常都是通过

0:50:30.600,0:50:33.160  
结合多项式 IOP 和多项式承诺方案获得的。

0:50:33.160,0:50:37.960  
FRI 和 KZG 是承诺方案的例子。

0:50:38.600,0:50:42.320  
所以 Spartan 也需要一个类似的承诺方案，

0:50:42.320,0:50:47.120  
并且任何承诺方案，比如如果你能计算离散对数，

0:50:47.120,0:50:49.880  
如果你是攻击者并且你能计算离散对数，

0:50:49.880,0:50:52.480  
或者如果你能找到哈希函数的碰撞，

0:50:52.480,0:50:54.280  
你就可以破坏承诺方案的约束性，

0:50:54.280,0:50:57.320  
从而从 SNARK 中找到令人信服的错误陈述的证明。

0:50:57.320,0:50:57.960  
Tracy：对。

0:50:57.960,0:50:58.680  
Justin：好的。

0:50:58.680,0:51:02.020  
对于 GKR，如果验证者知道电路的输入，那么——

0:51:02.020,0:51:07.080  
不涉及加密，所以没有哈希函数供攻击者尝试破解。

0:51:07.080,0:51:09.120  
你知道，攻击者可能需要数万亿年。

0:51:09.120,0:51:12.520  
而且无论如何，如果你以交互方式运行协议，

0:51:12.520,0:51:17.400  
其安全性来自于 Sum-Check 协议的第i轮中，

0:51:17.400,0:51:22.880  
当证明者发送其 3 次多项式时，它不知道验证者在该轮中将选择的随机点 rᵢ，

0:51:22.880,0:51:27.460  
验证者会用这个随机点来检查它的声明。

0:51:27.460,0:51:28.080  
Tracy：我明白了。

0:51:28.080,0:51:30.440  
Justin：所以在 Sum-Check 协议中，

0:51:30.440,0:51:34.880  
安全性来自于验证者挑战的不可预测性，

0:51:34.880,0:51:37.000  
而不是来自于加密。

0:51:37.000,0:51:39.320  
没有加密哈希函数或者群。

0:51:39.320,0:51:40.720  
Tracy：我明白了。

0:51:40.720,0:51:45.000  
Justin：现在，在 SNARK 应用中，验证者通常不知道 x，

0:51:45.000,0:51:46.480  
所以 x 将被承诺，

0:51:47.080,0:51:51.140  
但电路门的值不需要被承诺。

0:51:51.140,0:51:54.480  
Tracy：这样做的吸引力之一在于，

0:51:54.480,0:52:00.140  
证明者需要做的工作量是线性的，而不是 nlogn。

0:52:00.140,0:52:02.520  
Justin：对。所以这取决于我们讨论的承诺方案，

0:52:02.520,0:52:06.400  
如果我们进行承诺的话，这些承诺的成本会有多高。

0:52:07.200,0:52:14.040  
但一般来说，Sum-Check 证明者所做的域操作成本更低。

0:52:14.560,0:52:17.720  
譬如群操作是由域操作构建的。对吧？

0:52:17.720,0:52:23.160  
如果你避免使用群，你将不得不做哈希或 FFT 之类的操作，

0:52:23.160,0:52:26.120  
比如一个哈希或——

0:52:26.120,0:52:29.419  
所有这些都比两个域元素的加法或乘法要昂贵得多。

0:52:29.419,0:52:31.240  
Tracy：对。  
Justin：这就是大致的思路。

0:52:31.760,0:52:35.280  
现在在实践中一切都很复杂，但大致上就是这样。

0:52:35.280,0:52:39.920  
完全不进行承诺的缺点是，

0:52:39.920,0:52:43.000  
即使验证者知道 x，也可能会有一些缺点，

0:52:43.000,0:52:48.640  
比如很难或不可能使电路保持较小规模。

0:52:48.640,0:52:52.080  
所以有一些通用的技术来使电路保持较小规模，

0:52:52.080,0:52:55.960  
这样我们就可以将 SNARK 应用于较小的电路而不是大电路，

0:52:56.520,0:52:58.680  
使用大量不可信的建议。

0:52:58.680,0:53:02.200  
这意味着，如果你需要将两个量相除，

0:53:02.200,0:53:05.080  
不是让电路实际运行一个除法算法，

0:53:05.080,0:53:07.480  
而是让证明者提供商和余数，

0:53:07.480,0:53:12.080  
然后电路只需通过一次乘法和一次加法来检查它们是否正确。

0:53:12.720,0:53:14.960  
现在，如果没有承诺方案，

0:53:14.960,0:53:18.760  
这些不可信的建议要么必须显式地发送给验证者。

0:53:18.760,0:53:23.000  
但幸运的是，我们在 SNARK 设计中关心的许多电路，

0:53:23.000,0:53:24.320  
它们非常简单。

0:53:24.320,0:53:30.160  
即使没有任何不可信的建议，它们也只是像乘法门组成的二叉树。

0:53:30.160,0:53:31.280  
这被称为“grand product（大乘积）”。

0:53:31.280,0:53:32.080  
如果你想要——

0:53:32.080,0:53:36.640  
如果你只想计算 x 的所有条目的乘积，不需要任何建议。

0:53:36.640,0:53:39.040  
我只需在一棵树中把它们相乘就可以了。

0:53:39.040,0:53:39.952  
Tracy：我明白了。

0:53:39.952,0:53:42.620  
Justin：这正是我们开始看到 GKR 应用的地方。

0:53:42.620,0:53:43.200  
Tracy：好的。

0:53:43.200,0:53:46.200  
Justin：让我们快速看一下一个乘法门组成的二叉树。

0:53:46.200,0:53:51.600  
所以我们有x₁, x₂, x₃, x₄。

0:53:51.600,0:53:54.360  
我们想把这四个数相乘。

0:53:54.360,0:53:56.440  
所以这是实现这个功能的电路。

0:53:57.760,0:53:58.240  
好的。

0:53:58.240,0:54:01.600  
GKR 协议的工作方式是，

0:54:01.600,0:54:05.800  
证明者将发送所声称的输出门的值。

0:54:05.800,0:54:06.680  
Tracy：是的。

0:54:06.680,0:54:09.280  
Justin：验证者不相信这个声明，

0:54:09.280,0:54:14.160  
所以它将应用 Sum-Check 协议，将关于输出的声明

0:54:14.160,0:54:17.520  
简化为关于到输出的输入门的声明。

0:54:18.400,0:54:22.880  
现在，在这个小图中，你可以计算这些门，

0:54:22.880,0:54:24.280  
你知道，因为电路很小，

0:54:24.280,0:54:27.200  
也许验证者愿意自己计算这些门的值，

0:54:27.200,0:54:28.320  
并检查声明。

0:54:28.320,0:54:29.920  
Tracy：但如果这棵树非常大。

0:54:29.920,0:54:33.240  
Justin：验证者不想做所有的工作

0:54:33.240,0:54:35.880  
来计算到输出的输入门的值。

0:54:35.880,0:54:38.520  
所以你对此不满意，

0:54:38.520,0:54:41.240  
就像验证者在 Sum-Check 的第一轮结束时不满意一样，

0:54:41.240,0:54:42.720  
于是就继续到下一轮。

0:54:42.720,0:54:46.480  
所以你会再次应用 Sum-Check，将关于这些门的声明简化为——

0:54:46.480,0:54:47.760  
在这个情况下，是关于输入的声明，

0:54:47.760,0:54:51.200  
但一般来说，会是关于下一层、再下一层的声明，以此类推。

0:54:51.720,0:54:55.720  
所以在这个grand product的上下文中，

0:54:55.720,0:55:01.280  
证明规模方面，你最终会对电路的每一层应用 Sum-Check 协议，

0:55:01.280,0:55:05.000  
但电路的层数与我们相乘的元素数量的对数相关，

0:55:05.000,0:55:07.640  
也就是对数级别的层数。

0:55:07.640,0:55:11.360  
所以证明规模是对数的平方。

0:55:11.360,0:55:11.865  
好的。

0:55:11.865,0:55:12.705  
Tracy：我明白了。好的。

0:55:12.960,0:55:19.280  
Justin：在实践中，这可能是 1万 字节左右。

0:55:19.280,0:55:24.427  
所以不像 KZG 证明那么短，但比 FRI 证明或其他东西短得多。

0:55:24.427,0:55:25.120  
Tracy：是的。非常高效。

0:55:25.120,0:55:29.960  
Justin：这是大致的情况。而且——

0:55:30.800,0:55:36.040  
与 Spartan 这是否是重大提速，

0:55:36.040,0:55:41.480  
这其中存在一种权衡。与 Spartan 相比，验证者的成本会上升，

0:55:41.480,0:55:43.560  
但证明者的成本可能会降低，

0:55:43.560,0:55:47.960  
主要是因为你不需要对内部门的值进行承诺。

0:55:47.960,0:55:51.520  
Tracy：对于某些电路，这种权衡会有所改变，

0:55:51.520,0:55:52.960  
因为为了评估电路，你必须有大量

0:55:52.960,0:55:56.720  
额外的见证或建议。

0:55:56.720,0:55:57.560  
Justin：对。

0:55:57.560,0:56:02.920  
所以如果你不只是将所有输入相乘，并且电路还做了其他事情，

0:56:02.920,0:56:04.000  
可能——

0:56:04.000,0:56:05.840  
你可能没有办法在不使用大量不可信建议输入的情况下保持电路规模较小。

0:56:05.840,0:56:08.160  
在这种情况下，你可能还不如直接对所有内容进行承诺。

0:56:08.160,0:56:11.160  
但这些 grand product 似乎是高效 SNARK 的核心，

0:56:11.160,0:56:16.400  
并且它非常适合。

0:56:16.400,0:56:18.760  
你不需要任何不可信的建议。

0:56:18.760,0:56:22.160  
其他方面是——grand product的应用方式，

0:56:22.160,0:56:25.480  
相乘的那些东西是随机值，

0:56:25.480,0:56:30.200  
这往往使得对它们进行承诺的成本非常高。

0:56:30.200,0:56:34.040  
实际上，与它们是 “小值” 的情况相比，承诺的成本要高出一个数量级甚至更多。

0:56:34.040,0:56:40.231  
Tracy：我明白了。

0:56:40.231,0:56:40.840  
Justin：所以像 Spartan 那样省去这些承诺，

0:56:40.840,0:56:46.360  
可以真正为证明者节省大量时间。

0:56:46.360,0:56:48.800  
还有一些混合方法，

0:56:49.400,0:56:51.120  
你可以在不显著减慢 GKR 速度的情况下，

0:56:51.120,0:56:54.880  
获得Spartan的大部分证明规模的优势。

0:56:54.880,0:56:59.200  
然后——

0:56:59.200,0:57:00.040  
所以 Spartan 的证明者可能比 GKR 慢，

0:57:00.040,0:57:08.800  
但证明规模肯定更小。

0:57:09.560,0:57:13.280  
然后在我看来，任何不使用 Sum-Check 的方法，

0:57:13.280,0:57:16.760  
往往比两者都慢。

0:57:16.760,0:57:17.480  
Tracy：是的。

0:57:17.480,0:57:21.680  
Justin：因为它们不仅要对电路的内部门的值进行承诺，

0:57:21.680,0:57:23.640  
还会对其他许多东西进行承诺。

0:57:23.640,0:57:27.440  
通常会出现商多项式，计算起来很昂贵，

0:57:27.440,0:57:31.400  
可能会或可能不会被显式承诺，而使用 Sum-Check 就可以避免所有这些问题。

0:57:31.400,0:57:32.060  
Tracy：很酷。

0:57:32.060,0:57:32.360  
Tracy：是的。

0:57:32.360,0:57:35.000  
Plonk 中的商多项式特别大，

0:57:35.000,0:57:38.580  
因为输入门的次数很高。

0:57:38.580,0:57:39.720  
Justin：是的。没错。

0:57:39.720,0:57:45.960  
我认为 Plonk 的承诺成本确实随着约束的次数增加而增长。

0:57:45.960,0:57:49.600  
还有其他单变量 SNARK 不一定有这个问题，

0:57:49.600,0:57:53.160  
但仍然会在某个地方出现商多项式。

0:57:54.080,0:57:57.280  
是的。所以这些系统有很多组成部分，

0:57:57.280,0:58:05.800  
我认为承诺数据的量是衡量证明者效率的首要指标。

0:58:05.800,0:58:10.520  
但肯定不是说你想要不惜一切代价最小化承诺的数据量。对吧？

0:58:10.520,0:58:12.640  
承诺商和余数肯定比

0:58:12.640,0:58:15.600  
让电路在内部执行除法运算要好。对吧？

0:58:15.600,0:58:17.780  
Tracy：是的。
Justin：所以这可能是一个微妙的平衡。

0:58:17.780,0:58:19.360  
但我认为今天最流行的 SNARK 在这方面走得太远了，

0:58:19.360,0:58:23.680  
如果你关心的是证明者的时间的话。

0:58:23.680,0:58:25.960  
如果你过于偏向Sum-Check一边，你的电路会变得非常大。

0:58:26.480,0:58:30.200  
所以你希望处于两者之间的某个位置。

0:58:30.200,0:58:33.080  
但存在一个——

0:58:33.080,0:58:33.800  
你知道，我认为我们现在正在找到那个合适的平衡点。

0:58:33.800,0:58:37.880  
Tracy：很酷。太棒了。

0:58:37.880,0:58:39.120  
这是一个很好的概述。感谢您抽出时间！

0:58:39.120,0:58:40.780  
Justin：谢谢邀请我！