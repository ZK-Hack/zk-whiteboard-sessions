0:00:11.733,0:00:15.166
Nico: 欢迎来到ZK白板会议第二季

0:00:15.200,0:00:16.733
我是今天的主持人Nico

0:00:16.733,0:00:18.766
和我一起的还有来自 zkSecurity 的David

0:00:18.800,0:00:19.766
David: 哈喽，大家好

0:00:19.766,0:00:22.466
Nico: 如果你还没有看过第一季，
我鼓励你去看一下

0:00:22.466,0:00:26.000
因为本季我们将基于先前这些模块中学到的知识

0:00:26.033,0:00:28.833
我们在ZK Hack Discord还有一个学习俱乐部

0:00:28.833,0:00:31.733
在这里，我们每周都会复习课程

0:00:31.733,0:00:35.000
事实上，正是通过做这些
我们认识到

0:00:35.033,0:00:38.233
有些内容没有学到
或是有些内容需要更新

0:00:38.233,0:00:40.333
因此，我们又推出了一套新课程

0:00:40.333,0:00:44.766
课程由以太坊基金会 ZK 资助计划提供赞助

0:00:44.800,0:00:47.600
今天的内容是 "什么是 ZK"？

0:00:47.600,0:00:50.900
我的意思是 "什么是零知识？" 实际的密码学性质

0:00:50.900,0:00:53.100
这是非常重要的事情，因为

0:00:53.100,0:00:55.800
在我们之前的系列中，
我们并没有真正涉及到这一点

0:00:55.833,0:01:00.333
David, 今天我们来回顾一些理论
当然也还有一些实践

0:01:00.333,0:01:02.366
看看我们的老朋友 PLONK

0:01:02.400,0:01:03.666
David: 是的

0:01:03.700,0:01:08.833
大家总是谈论ZKP, 零知识证明之类的东西

0:01:08.833,0:01:11.300
ZK总是有点神秘

0:01:11.300,0:01:13.333
就好像我们并不真正关心它

0:01:13.333,0:01:17.666
所以我们要更深入地了解它到底是什么

0:01:17.700,0:01:22.200
我们可以讨论的第一件事是
从高层次来看，ZK 的 API 是什么？

0:01:22.200,0:01:23.366
Nico: 当然

0:01:24.466,0:01:29.900
所以，如果你想到一个证明者和一个验证者，
以及所有这些事物，并且你去抽象它们

0:01:30.666,0:01:36.533
他们真正在做的是证明一个程序、一个陈述或任何其他事物。

0:01:36.533,0:01:41.566
在我们这个时代，我们会想到程序，
因为我们关注的是通用的零知识证明（ZKP）

0:01:41.600,0:01:45.400
所以这里我们有一些——可以说是某个函数

0:01:46.233,0:01:50.733
这个函数输入一些参数（arguments）

0:01:50.733,0:01:58.766
也许我会把它写成大写 ARG2 和 小写arg1，
它可能会有一些输出

0:01:58.800,0:02:00.800
这完全是计算上的

0:02:00.800,0:02:06.233
就像你在电脑上运行它，也许你想向我证明

0:02:06.233,0:02:09.800
使用这些输入运行这个函数会得到这个输出，对吗？

0:02:09.800,0:02:17.000
通常我们谈到零知识（ZK），
ZK会出现在你想隐藏某些内容的时候

0:02:17.033,0:02:19.366
比如说，你想向我证明你在计算这个东西

0:02:19.366,0:02:22.433
但你又不想告诉我这些输入

0:02:23.133,0:02:26.166
一个典型的例子是数独求解器

0:02:26.200,0:02:31.100
这是一个缺少一些格子的数独网格

0:02:31.100,0:02:33.966
这是实际的解

0:02:34.000,0:02:37.000
而这是说“对，这个解答是对的”，
同时你将它隐藏了

0:02:38.200,0:02:39.933
David：希望这能帮助大家理解

0:02:41.500,0:02:44.933
我总是告诉别人，如果你想理解 ZK，
不要直接想 ZK

0:02:44.933,0:02:49.533
先想纯粹的计算，然后再想你想隐藏什么

0:02:49.533,0:02:54.333
你不需要理解 ZK 的工作原理，
可以从一个高层次来理解它

0:02:55.200,0:03:02.800
似乎很多时候，人们更关心现代方案中的简洁性

0:03:02.800,0:03:06.000
通常，我们不会单独谈论 ZK

0:03:06.000,0:03:09.900
我们更倾向于讨论 zk-SNARKs 或 SNARK

0:03:09.900,0:03:13.033
我可能会写下来

0:03:13.066,0:03:16.600
简洁性体现在“简洁”（succinctness）这个“S”上

0:03:16.633,0:03:21.566
我不太确定“succinctness”这个词怎么写

0:03:21.600,0:03:25.100
如果我写错了，大家可以随意纠正我

0:03:25.100,0:03:28.566
基本上，它的意思是，你可以向我证明这段计算

0:03:29.600,0:03:36.900
但是当我验证你的证明,它是一种对这段计算的签名

0:03:36.900,0:03:40.533
验证的时间会比我自己运行这些参数

0:03:40.533,0:03:43.466
并完成计算的时间少

0:03:44.300,0:03:46.800
David：对吧？所以这是个很有趣的点

0:03:46.800,0:03:50.066
ZKP 实际上有两个有趣的方面

0:03:50.066,0:03:54.366
你可以证明一段计算,并隐藏部分输入或输出

0:03:56.033,0:03:59.700
你可以隐藏这些，或者隐藏那些，或者任何你想隐藏的内容

0:04:01.666,0:04:05.133
虽然如果你把所有东西都隐藏起来就没有太大意义了

0:04:05.700,0:04:12.133
此外，还有简洁性，它让我验证证明的成本非常低

0:04:12.166,0:04:15.533
Nico：所以简洁性和零知识是两种不同的性质

0:04:15.533,0:04:18.666
而且，它们可以独立存在？

0:04:18.700,0:04:19.833
David：没错！

0:04:19.833,0:04:23.333
有些方案不简洁，有些方案不支持零知识

0:04:23.333,0:04:25.466
事实上，大多数方案并不支持零知识

0:04:25.500,0:04:29.000
你可以根据需要再加上零知识性，

0:04:29.033,0:04:32.133
这可能很容易，也可能需要认真设计

0:04:33.266,0:04:38.100
我们还应该提到，很多方案甚至没有使用零知识性质

0:04:38.100,0:04:42.200
比如现代 zk-Rollups 或所谓的 zk-Rollups

0:04:42.200,0:04:43.500
Nico：他们都不是零知识的？

0:04:43.500,0:04:47.733
David：严格来说并不是零知识的，
因为它们没有隐藏任何东西

0:04:47.733,0:04:52.866
它们主要关注如何压缩计算，以便更容易验证

0:04:52.900,0:04:53.666
是的

0:04:53.700,0:04:57.866
Nico：我们是否应该定义一下零知识？
比如我们指的零知识是什么？

0:04:57.866,0:04:58.633
David：嗯，

0:04:58.666,0:04:59.400
Nico：它的性质？

0:04:59.400,0:05:00.933
David：从高层次上看是这样的

0:05:00.933,0:05:05.600
但如果我们深入探究——这背后有更深层的含义

0:05:05.633,0:05:09.333
作为密码学家，我们必须思考这更深层的意义

0:05:10.200,0:05:14.800
所以我们可以这样思考

0:05:14.800,0:05:18.866
想象我是证明者，你是验证者

0:05:18.866,0:05:22.733
我想向你证明一些事情，但同时我也希望隐藏某些信息

0:05:23.300,0:05:27.566
我们可以想象这些方案通常是这样工作的，对吧？

0:05:27.600,0:05:29.133
我们在通信

0:05:29.133,0:05:33.166
我给你发送一条消息，你给我发送一条消息，我再给你发送一条消息

0:05:33.200,0:05:35.066
我们不断地来回传递信息

0:05:35.066,0:05:38.766
事实上，很多非常基础的方案只有三条消息

0:05:38.800,0:05:42.100
我们称之为“Sigma协议”，因为它的形状类似于Sigma符号

0:05:43.000,0:05:49.200
在这里，我想向你证明一些事情，但我不想泄露这个信息

0:05:50.800,0:05:57.500
所以这个思路是，或者我们试图理论化的，是这样的：

0:05:57.500,0:06:03.733
假设我正在和你对话

0:06:03.733,0:06:05.133
也许我可以这么说

0:06:05.133,0:06:07.033
假设我是证明者，对吧？

0:06:07.066,0:06:07.966
Nico：当然。

0:06:08.000,0:06:14.133
我不确定我们是否会在某个时候提到可靠性（soundness）

0:06:14.166,0:06:16.666
也许我也应该提一下它

0:06:16.700,0:06:19.933
证明系统有相互竞争的特性

0:06:21.833,0:06:24.100
作为验证者，你想确保我没有欺骗你

0:06:24.100,0:06:29.533
而作为证明者，我想确保你没有从我这里获取信息，对吧？

0:06:29.533,0:06:30.533
Nico：有道理。

0:06:30.533,0:06:39.000
因此，作为证明者，不，作为验证者

0:06:39.033,0:06:42.966
你想知道你是否能分辨出，是你在和我对话

0:06:43.000,0:06:51.500
还是你在和一个，我们称之为模拟器的的东西对话

0:06:51.500,0:06:53.733
这就是理论层面的内容

0:06:54.633,0:07:01.766
如果你可以和一个完全不知道数独解答的模拟器对话

0:07:01.800,0:07:06.700
并且它给你的结果和你与我，
一个真正的证明者对话时的结果一样

0:07:06.700,0:07:09.933
那么你无法区分你是在和我对话

0:07:09.933,0:07:12.400
还是在和一个甚至不知道实际情况的模拟器对话一样

0:07:12.566,0:07:14.766
此时我们可以称它为见证（witness）

0:07:16.000,0:07:18.633
那么这个方案就是零知识的

0:07:18.633,0:07:20.166
这是我对它的解释

0:07:20.200,0:07:25.000
或许听起来有点抽象，但我想介绍一下模拟器的概念

0:07:25.000,0:07:30.233
Nico：所以直觉上，虽然模拟器不知道witness

0:07:30.233,0:07:31.400
但我们可以进行这样的交互？

0:07:31.400,0:07:32.300
David：对

0:07:32.300,0:07:35.800
我写下“witness”这个词，因为我们刚刚提到了它

0:07:36.400,0:07:38.933
witness是我们试图隐藏的东西

0:07:42.266,0:07:46.100
所以我会写下模拟器的接口

0:07:46.866,0:07:51.133
但假设这个论据实际上不是零知识的，比如它是公开的

0:07:51.133,0:07:56.000
我们通常称它为声明（statement）

0:07:56.033,0:08:01.900
所以声明通常是公开的，而witness是你试图隐藏的东西

0:08:01.900,0:08:08.166
因此，模拟器，假设 S，通常只接收statement

0:08:08.200,0:08:11.733
通常 x 是statement，w 是witness

0:08:11.733,0:08:15.000
模拟器通常只输入statement

0:08:15.033,0:08:19.900
而另一方面，证明者通常输入witness和statement

0:08:19.900,0:08:24.133
比如“数独网格”和“数独解答”

0:08:24.133,0:08:29.400
所以你可以想象，作为验证者

0:08:30.033,0:08:32.866
如果你可以仅仅与一个不知道witness的模拟器对话

0:08:32.866,0:08:37.933
而它看起来和与证明者对话时一样

0:08:37.933,0:08:39.333
那么当你与证明者交互时，你也不会得到任何东西

0:08:39.333,0:08:42.233
Nico：有道理

0:08:42.266,0:08:44.733
我们是否应该看看
一个模拟器的具体例子？

0:08:44.900,0:08:50.433
David：一个很好的例子是 Schnorr

0:08:52.600,0:08:55.700
David：Schnorr 身份协议

0:08:58.200,0:09:04.800
Schnorr 身份协议非常简单，它是 Schnorr 签名的基础

0:09:04.800,0:09:11.233
实际上，ECDSA 签名也遵循类似的模式

0:09:12.266,0:09:16.900
它是一个离散对数的零知识证明

0:09:16.933,0:09:17.966
Nico：明白

0:09:18.000,0:09:19.733
David：在这个场景中

0:09:19.733,0:09:27.966
证明者知道某个值 Y 的离散对数，我们称之为 x

0:09:28.000,0:09:31.933
他们想向验证者证明
（假设我是证明者，你是验证者）

0:09:31.933,0:09:35.233
他们想证明他们知道这个 x

0:09:35.266,0:09:38.866
这个协议的工作方式是一个三步的，也就是 Sigma 协议

0:09:38.866,0:09:45.566
它的工作方式是，通常你会先发送一个，你对一个值进行承诺

0:09:46.833,0:09:48.933
我就叫它 r

0:09:48.933,0:09:54.600
你承诺一个预期是随机生成的值

0:09:54.633,0:10:02.133
然后你会从验证者那里收到一个挑战，
并且希望这个挑战也是随机的

0:10:02.133,0:10:03.800
稍后我们会进一步讨论这个问题

0:10:04.600,0:10:13.400
然后你会发送一些内容，比如说，应该是r+c⋅x

0:10:13.400,0:10:15.500
这是证明者可以计算的值

0:10:15.500,0:10:20.333
因为 x 乘以挑战的结果再加上你承诺的值

0:10:21.433,0:10:26.466
这个协议是可靠的且完备的

0:10:26.466,0:10:27.700
意味着它是一个零知识证明

0:10:30.000,0:10:32.266
如果我知道x的值，我就能向你证明它是完备的

0:10:32.266,0:10:35.200
它是可靠的，如果我不知道x的值，我就不能对你说谎

0:10:35.200,0:10:37.333
Nico：我们是不是漏掉了一个验证步骤？

0:10:37.333,0:10:40.133
David：是的。验证者在最后做什么？

0:10:42.066,0:10:47.666
所以z显然是你需要发送的东西，所以证明者会发出z

0:10:47.666,0:10:51.766
然后验证者会检查它是否等于--有很多种方法来进行这个检查

0:10:51.800,0:11:00.200
这是可以做的一种方式

0:11:05.033,0:11:08.266
yᶜ乘以R

0:11:08.833,0:11:09.733
让我们打开承诺

0:11:09.733,0:11:23.066
所以 yᶜ 是 gˣᶜ 乘以 gʳ，这就是z

0:11:23.100,0:11:26.633
好的，我们第一次写就对了

0:11:27.266,0:11:32.800
所以这个方案很不错，是完备的，它用的是 Schnorr 签名

0:11:32.833,0:11:35.866
接下来我们来看为什么它是零知识的，
或者为什么它不是零知识的

0:11:37.066,0:11:41.800
好的，让我们把这些擦掉

0:11:41.833,0:11:44.100
所以我们将讨论模拟器的概念

0:11:44.100,0:11:48.900
在这里，模拟器想要做的是
你作为验证者

0:11:48.900,0:11:53.400
你会调用这个模拟器并看看它是否能够工作

0:11:53.433,0:11:58.900
基本上，这个工作方式是你希望生成一个副本

0:11:58.900,0:12:04.933
它看起来像是消息₁、消息₂、消息₃

0:12:04.933,0:12:08.366
也就是第一步、挑战值和 z

0:12:08.366,0:12:12.633
你希望它可以验证

0:12:12.933,0:12:13.600
Nico：这个等式？

0:12:13.633,0:12:14.966
David：没错

0:12:15.633,0:12:21.233
即使生成这些副本的模拟器并不知道 x，对吧？

0:12:21.700,0:12:26.800
它们基本上是乱序的

0:12:26.833,0:12:32.433
它们知道验证者会抽取一个随机值

0:12:32.433,0:12:37.300
因此，它们提前选择一个随机 c

0:12:37.300,0:12:43.633
然后它们选择一个随机 z

0:12:43.666,0:12:45.933
它们能力很强，所以无所谓

0:12:45.933,0:12:51.866
然后它们会说，它们知道自己是乱序进行的

0:12:51.900,0:12:57.500
它们会说 m1 或者任何 R 是

0:13:04.066,0:13:08.866
Nico：我们知道这个值和这个值，那么我们可以设定这个值吗

0:13:08.866,0:13:15.866
David：对，你希望 R 等于

0:13:15.866,0:13:27.000
它等于gᶻ 除以 yᶜ 或是乘 y⁻ᶜ

0:13:27.033,0:13:34.166
你知道这个值，你基本上知道这里的所有内容

0:13:34.200,0:13:37.833
所以你可以计算出这个值并验证公式是否成立

0:13:42.766,0:13:46.500
这是模拟器可以生成的记录

0:13:46.500,0:13:48.900
它并不知道witness

0:13:48.900,0:13:52.433
它只是凭空生成了这个 R

0:13:52.466,0:13:54.466
你可以验证这些副本

0:13:54.466,0:13:58.733
而它不会告诉你任何关于witness的信息

0:13:58.733,0:13:59.166
Nico：明白了。

0:13:59.200,0:14:01.133
基本上就是这个思路

0:14:01.133,0:14:04.666
Nico：所以Schnorr 身份协议是零知识的

0:14:04.700,0:14:06.433
是因为我们能够生成这些副本？

0:14:06.466,0:14:11.866
David：严格来说，它并不是零知识，
因为这里我们做了一个假设

0:14:11.866,0:14:18.166
我们假设这里的挑战

0:14:18.333,0:14:20.333
是从均匀分布中采样的

0:14:21.066,0:14:22.800
但这并不总是成立

0:14:23.500,0:14:27.800
David：验证者可能会变得“狡猾” 试图从你这里获取信息

0:14:27.833,0:14:33.300
并可能向你发送特定的值来试图泄露你的数据

0:14:33.300,0:14:41.033
所以在这种情况下，我们做了一个假设

0:14:41.833,0:14:47.566
称之为诚实验证者零知识（Honest-Verifier ZK）

0:14:47.600,0:14:52.533
通常我们写成 HVZK

0:14:52.533,0:14:55.166
需要注意的是

0:14:55.200,0:14:59.033
当你想写基于模拟器的证明时

0:14:59.033,0:15:02.533
你需要尝试理解模拟器可以做什么

0:15:02.533,0:15:06.000
如果你从诚实验证者的假设开始

0:15:06.200,0:15:11.666
在这种情况下，验证者可以自行选择这些挑战

0:15:11.933,0:15:16.400
或者说它们已经提前得到了所有的挑战

0:15:16.433,0:15:18.333
并且它们确切地知道挑战是什么样的

0:15:18.333,0:15:20.933
这是两个相似的模型

0:15:21.533,0:15:24.666
不过通常

0:15:24.700,0:15:26.033
有两派观点

0:15:27.100,0:15:31.533
有一派不太喜欢 HVZK，因为它可能会

0:15:31.566,0:15:35.800
也许存在一些攻击方式，
可以泄露有关你的witness的信息

0:15:37.833,0:15:40.533
我们可以现在讨论这两种情况

0:15:40.533,0:15:43.766
我们可以谈论那个，或者我们可以谈谈

0:15:43.800,0:15:47.433
为什么实际上HVZK是可以接受的

0:15:47.433,0:15:50.533
Nico：在我们深入讨论这些话题之前，我有一个问题

0:15:50.533,0:15:54.833
是什么阻止了一个恶意的证明者

0:15:54.866,0:15:57.533
在没有证据的情况下证明某件事情？

0:15:57.533,0:15:59.966
David：这不会破坏协议的可靠性

0:16:00.000,0:16:00.833
这是个很好的问题，

0:16:00.833,0:16:03.366
因为这里我们是乱序进行的

0:16:03.833,0:16:05.500
David：我们提前知道了挑战

0:16:05.633,0:16:10.133
然后在知道挑战后生成了 R

0:16:10.133,0:16:16.766
而这些协议实际上是提交后接受挑战的形式

0:16:17.166,0:16:21.033
在这种情况下，按顺序操作是非常重要的

0:16:21.300,0:16:28.900
David：所以，诚实验证者
我们需要它吗？或者我们不需要它？

0:16:29.800,0:16:33.266
如果我们在做交互式协议，这真的很重要

0:16:33.266,0:16:39.300
从这个意义上来说，我们不希望验证者发送恶意挑战，
因为这可能会泄露信息

0:16:39.300,0:16:40.966
所以事实证明

0:16:41.000,0:16:44.866
例如，在这个 Schnorr 身份协议的例子中

0:16:44.866,0:16:49.066
它不是针对不诚实验证者的零知识，
因为这里确实存在一些问题

0:16:49.066,0:16:52.133
我们不知道如何构造一个模拟器

0:16:53.866,0:16:57.566
可以生成你能验证的内容，并且它能够正常工作

0:16:57.600,0:17:04.000
原因是如果我们假设挑战可能不是均匀随机的

0:17:04.000,0:17:09.600
那么模拟器基本上需要猜测挑战会是什么

0:17:09.600,0:17:14.466
因此，在这个步骤中，它需要生成某个 R，同时猜测 c

0:17:14.466,0:17:17.533
然后它会继续与验证者交互

0:17:17.533,0:17:24.200
所以我们说这里的模拟器可以“预言机”访问验证者

0:17:25.100,0:17:28.366
然后它会发现挑战实际上并不是它所想象的那样

0:17:28.400,0:17:32.100
因为采样空间可能非常大

0:17:32.100,0:17:34.533
因此它需要回退并重新尝试

0:17:34.533,0:17:40.766
它可以多次尝试，但问题是它的运行时间是有限的

0:17:40.800,0:17:46.966
所以它很可能永远无法猜中实际的挑战

0:17:47.633,0:17:49.433
David：如果他们能够猜到实际的挑战值

0:17:49.466,0:17:51.866
这可能意味着这个方案并不安全

0:17:53.466,0:17:58.466
不过，其实我要收回这句话，接下来我来说明原因

0:17:58.466,0:18:04.600
一种让这个协议成为“非诚实验证者零知识”（DVZK）
或者我们所说的普通的零知识（plain ZK）的方法

0:18:04.633,0:18:09.233
是让挑战值 c 从一个非常小的范围中采样

0:18:09.233,0:18:10.866
所以，如果你

0:18:14.300,0:18:19.933
如果你将 c 从 0 或 1 中采样，比如作为一个比特值

0:18:20.200,0:18:27.733
那么我们可以证明这是零知识的，因为此时模拟器可以通过

0:18:28.833,0:18:35.000
猜测它是 0 还是 1，预期两次尝试就可以猜中

0:18:36.466,0:18:38.500
也许第一次猜不中

0:18:38.500,0:18:40.766
但第二次预期会猜中

0:18:40.800,0:18:43.400
这没问题，因为模拟器可以做到这一点

0:18:43.400,0:18:48.866
它是一个多项式时间上界的算法

0:18:48.866,0:18:52.600
Nico：这是否会带来某种代价？比如降低可靠性？

0:18:52.633,0:18:53.333
David：是的

0:18:53.333,0:18:54.533
这确实有点糟糕，对吧？

0:18:54.533,0:18:58.666
因为在这种情况下，真实的证明者也基本上有

0:18:59.733,0:19:03.566
50%的概率正确猜测挑战值

0:19:03.733,0:19:06.366
所以问题在于，即使证明者不知道witness

0:19:06.433,0:19:09.533
一半的情况下它们也能正确地通过证明

0:19:09.533,0:19:14.233
因此，在这些方案中，你通常需要多次重复协议

0:19:14.266,0:19:16.900
因为这里的可靠性是 1/2

0:19:16.900,0:19:20.966
但如果你重复很多次

0:19:21.000,0:19:25.600
证明者需要连续 100 次正确猜测 c

0:19:25.966,0:19:26.866
这就更难了

0:19:26.866,0:19:28.700
或者更多次

0:19:29.000,0:19:32.300
Nico：你说过 Schnorr 签名基于这个思想

0:19:32.300,0:19:34.600
我们在 Schnorr 签名中不会这样做吧？

0:19:34.633,0:19:35.900
David：对

0:19:35.900,0:19:37.766
我们在签名中不会这样

0:19:38.100,0:19:40.033
那样会很糟糕

0:19:40.033,0:19:44.666
在 Schnorr 签名中，我们使用一个非交互式协议

0:19:44.666,0:19:47.400
我就不多提这个了

0:19:47.433,0:19:52.466
基本上是，我可以生成一个证明
不需要交互，你可以直接验证

0:19:52.466,0:19:59.233
为了实现这一点，我们使用了一种称为
Fiat–Shamir 转换的方法

0:19:59.333,0:20:05.933
因为有两个人，一个叫 Fiat，一个叫 Shamir，
如果我没记错的话，那时我可能还没出生

0:20:05.933,0:20:09.600
他们发明了这个东西，其基本思想是：

0:20:09.633,0:20:16.333
如果你知道这些是公开随机的消息，
也就是说它们是随机且公开的

0:20:16.333,0:20:17.766
Nico：来自一个大的分布，对吗？

0:20:17.800,0:20:18.766
David：来自一个大的分布

0:20:22.533,0:20:25.933
我们称它们为“公开随机消息”（public coin 
messages），但这并不重要

0:20:25.933,0:20:28.600
这只是我们使用的术语，它是公开的随机值

0:20:29.400,0:20:33.500
然后你可以用哈希函数替换这些内容

0:20:33.500,0:20:34.733
基本上，这是这个思路

0:20:35.433,0:20:39.233
不过当然，在理论上我们称它们为“随机预言机”

0:20:47.200,0:20:51.733
所以当我们开始使用哈希函数时

0:20:54.066,0:20:58.900
现在我们仍然处于理想模型中，我们仍然在使用理想的构造

0:20:58.900,0:21:02.366
但当我们实例化这些时，通常我们会使用哈希函数

0:21:02.400,0:21:05.500
因此，当我们切换到这些东西上

0:21:05.500,0:21:10.233
我们会说我们在随机预言机模型（ROM）中

0:21:11.200,0:21:12.700
这是一个术语

0:21:12.700,0:21:15.033
其实没那么重要，但了解一下也不错

0:21:15.700,0:21:22.000
我们在这里做的就是将验证者的所有交互替换为哈希函数

0:21:22.033,0:21:24.266
在这些 Sigma 协议中，这非常简单

0:21:24.266,0:21:26.766
你只需对第一部分进行哈希

0:21:26.800,0:21:30.133
因此，副本看起来像 你会移除挑战值

0:21:30.133,0:21:34.600
当你验证这些副本时，基本上你会

0:21:34.633,0:21:39.900
用 Hash(R) 替代c

0:21:39.900,0:21:41.966
Nico：也许还包括 y，对吧？

0:21:42.000,0:21:43.266
David：也许包括statement

0:21:43.266,0:21:44.866
这就是问题所在

0:21:44.866,0:21:48.066
通常大家并不确定

0:21:48.066,0:21:52.366
在 Fiat–Shamir 转换中应该包括什么

0:21:52.400,0:21:54.100
通常你想包含

0:21:54.100,0:21:57.366
尽可能多的东西

0:21:57.400,0:22:00.600
我相信实际上存在一些问题

0:22:00.600,0:22:03.033
当人们实例化签名时，他们没有包含

0:22:03.033,0:22:05.500
公钥，这里的 y 就是公钥

0:22:06.533,0:22:12.066
著名的 EdDSA 就包含了公钥

0:22:12.100,0:22:15.033
所以避免了一些复杂的攻击

0:22:15.600,0:22:16.733
但是

0:22:16.733,0:22:18.600
值得一提的是

0:22:18.633,0:22:22.733
但现在，我们有更高级的 SNARKs

0:22:22.733,0:22:27.233
它们有点类似于 Sigma 协议，但要长得多

0:22:27.266,0:22:28.966
有更多的挑战值

0:22:29.000,0:22:31.900
因此在这里，Fiat–Shamir 转换会复杂一些

0:22:31.900,0:22:33.966
你需要不断地进行哈希

0:22:34.000,0:22:39.633
你需要连续地对到目前为止的记录进行哈希，
以生成这些挑战值

0:22:39.633,0:22:42.366
而在这种情况下，这种方案容易出现很多漏洞

0:22:42.400,0:22:47.233
Nico：所以在这种情况下，我们用随机预言机
或哈希函数替换了验证者

0:22:47.233,0:22:51.066
这是否意味着它现在表现得诚实了，
并且足够安全了？

0:22:51.066,0:22:53.700
David：是的。所以这里的想法是

0:22:55.200,0:23:00.500
在这种模型中，你可以说 Fiat–Shamir 转换是一种编译器

0:23:00.500,0:23:03.833
而如果我们在诚实验证者模型中，那么这没问题

0:23:03.866,0:23:06.133
比如我们不是在 ZK 模型中

0:23:06.766,0:23:10.100
David：它是安全的，或者你可以说

0:23:11.266,0:23:19.333
你可以用另一种方式来分析，比如说你是在 EP ROM 模型中

0:23:21.700,0:23:23.200
Nico：E 和 P 是什么意思？

0:23:23.233,0:23:39.000
David：E 是 Explicit Programmable（显式可编程），
或者 Explicitly Programmable

0:23:41.500,0:23:45.533
这意味着，一旦你到达需要对 R 进行哈希的挑战

0:23:45.533,0:23:51.266
假设我们把statements也包括进去

0:23:52.100,0:23:57.300
当你这样做时，当你调用随机预言机时

0:23:57.400,0:24:05.133
基本上——模拟器就会选择并设置这个随机预言机的返回值

0:24:05.733,0:24:09.000
所以它们基本上拥有超能力一样

0:24:09.533,0:24:12.933
没有这种超能力，它们就无法生成有效的记录。

0:24:12.966,0:24:14.300
Nico：明白

0:24:14.300,0:24:17.800
对，因为我们需要在知道 R 之前知道这个值？

0:24:17.800,0:24:18.833
David：对

0:24:22.500,0:24:31.000
David：到目前为止，我还没有真正谈到 CRS
（公共参考字符串）的内容，这里还有更多的超能力

0:24:31.033,0:24:36.866
但或许在我们讨论那个之前， 我们先谈谈零知识的不同类型

0:24:37.633,0:24:42.500
然后我们可以谈谈我们著名的 SNARKs

0:24:42.500,0:24:47.033
以及模拟器如何在这种世界中进行操作

0:24:47.066,0:24:49.700
而不是简单的 Sigma 协议

0:24:51.466,0:24:56.366
那么，零知识有哪三种类型？

0:24:56.400,0:25:03.200
我们谈到零知识时会提到完美零知识（Perfect ZK）

0:25:03.200,0:25:12.466
零知识的第二种类型是统计零知识（Statistical ZK）

0:25:12.466,0:25:16.933
第三种类型是计算零知识（Computational ZK）

0:25:16.933,0:25:24.133
Nico：在所有这些情况下，我们都会有
诚实验证者和恶意验证者的变体吗？

0:25:24.133,0:25:27.166
David：是的。所以你可以把它们全部组合起来

0:25:27.200,0:25:28.800
在每种情况下都有

0:25:28.800,0:25:31.100
所以你可以组合所有的“冰淇淋口味”

0:25:31.100,0:25:32.033
Nico：选择我的配料

0:25:32.066,0:25:32.866
David：对

0:25:32.866,0:25:37.366
这可能是像香草之类的东西

0:25:37.400,0:25:39.433
我们不太喜欢这一种

0:25:39.433,0:25:40.633
我的意思是，这取决于个人喜好

0:25:41.633,0:25:43.000
但这没关系。这并不意味着它不好

0:25:43.000,0:25:45.666
Nico：那么我们的三种“口味”有什么区别？

0:25:45.700,0:25:49.366
David：要理解它们的区别，我们必须看看概率

0:25:50.300,0:25:52.766
David：我之前谈到了模拟器

0:25:52.800,0:25:56.233
以及验证者如何与模拟器交互

0:25:56.233,0:26:00.733
以及模拟器如何拥有对验证者的预言机访问权，等等

0:26:00.733,0:26:03.833
可能有点让人困惑，所以我们把它写下来

0:26:04.933,0:26:07.033
像在密码学中常见的那样，我们模拟游戏

0:26:07.066,0:26:11.400
然后我们检查这些游戏的概率

0:26:16.266,0:26:21.800
在这里，我们玩一个游戏，其中验证者充当某种敌手的角色

0:26:21.833,0:26:24.666
他们想知道他们在与模拟器还是证明者对话

0:26:24.666,0:26:28.000
以及它们之间是否存在差异

0:26:29.400,0:26:35.133
所以我们从证据和实例开始

0:26:35.133,0:26:36.866
它们由敌手提供

0:26:37.900,0:26:45.333
然后我们随机生成一个比特

0:26:45.333,0:26:47.400
然后我们说

0:26:47.433,0:26:58.233
如果 b = 0，证明是由证明者基于witness和statement生成的

0:26:59.033,0:27:04.100
如果b = 1，则由模拟器生成

0:27:04.100,0:27:05.533
基本上，我们在玩这个游戏

0:27:05.533,0:27:09.333
但我们不知道是在与证明者对话还是与模拟器对话

0:27:09.933,0:27:11.666
然后敌手

0:27:11.700,0:27:19.500
我这里稍微简化了一些，攻击者通常会接收更多的输入

0:27:19.500,0:27:29.900
现在敌手接收证明和statements，然后做出响应，比如 b'

0:27:31.266,0:27:33.400
基本上，敌手试图猜测

0:27:33.433,0:27:37.666
他们是在与证明者对话还是模拟器对话，
他们试图区分两者

0:27:37.666,0:27:39.966
所以你可能会在某些定义中看到一个 d

0:27:40.666,0:27:47.066
在这里，我们想要检查他们成功猜对的概率

0:27:52.233,0:27:59.333
可能我遗漏了一些细节，但大致就是这个意思

0:27:59.333,0:28:03.666
让我们再看看

0:28:04.533,0:28:07.833
攻击者选择实例和证据

0:28:08.933,0:28:12.866
然后由证明者或模拟器生成证明，攻击者试图区分

0:28:12.900,0:28:17.900
Nico：区分是哪一个，好的。 所以这个概率应该是

0:28:17.900,0:28:19.833
David：最好的情况是什么？

0:28:19.866,0:28:22.066
Nico：对我们来说的最佳情况？

0:28:22.066,0:28:25.566
嗯，应该是一半，对吧？我们猜测一个比特

0:28:25.566,0:28:26.166
David：对

0:28:26.166,0:28:27.566
Nico：所以这是 50% 的几率

0:28:27.566,0:28:28.366
David：完全正确

0:28:28.400,0:28:31.866
如果这个概率是一半

0:28:31.900,0:28:35.866
David：或者恰好是一半，实际上，我们就处于完美的世界中

0:28:37.800,0:28:41.533
这就是我们希望见到的情况

0:28:41.533,0:28:50.300
如果它接近一半，但有一些可以忽略的小误差

0:28:55.433,0:29:01.933
如果非常接近二分之一，我们称之为统计性的

0:29:02.166,0:29:08.700
现在如果它接近一半，但攻击者能力是受限的

0:29:09.200,0:29:14.133
因为到目前为止，我们基本上假设攻击者是无限制的，直到——

0:29:14.600,0:29:15.666
David：无限能力

0:29:16.233,0:29:17.833
这也很有意思

0:29:19.033,0:29:21.333
但如果我们现在限制了攻击者的能力

0:29:21.333,0:29:26.466
这其实在现实世界中并不是一个太糟糕的假设

0:29:26.500,0:29:31.966
因为计算机的能力是有限的，因此说我们是在计算零知识（Computational ZK）里

0:29:32.000,0:29:35.600
Nico：好的。比如离散对数这样的东西就是计算型的，对吧？

0:29:35.600,0:29:36.166
David：是的。所以——

0:29:39.633,0:29:44.866
如果你看不同的证明是如何生成的，或者不同的攻击

0:29:44.866,0:29:49.200
你会发现有时候敌手能够计算这些东西

0:29:49.233,0:29:51.366
因此这些证明通常是在这些模型中使用的

0:29:53.533,0:29:58.000
那么，David，我想问一下，现在这些东西如何应用到

0:29:58.033,0:30:00.633
我们在这个系列中更熟悉的协议中呢？

0:30:00.633,0:30:02.266
比如说 PLONK？

0:30:02.300,0:30:05.133
David：好的，我想想——

0:30:09.666,0:30:12.700
我们这里不谈 Schnorr 因为那是 Sigma 协议

0:30:13.333,0:30:17.066
而我们现在讨论的是 PLONK 或现代的 SNARKs

0:30:17.100,0:30:18.133
Nico：是的

0:30:18.133,0:30:22.133
David：有几种不同的方法来实现零知识

0:30:22.133,0:30:28.133
或者尝试使用模拟器生成这些证明

0:30:28.133,0:30:30.833
当然，事情变得更加复杂，我们有很多交互

0:30:30.866,0:30:35.666
在最终的副本中有很多消息

0:30:36.700,0:30:40.533
所以很难在这次白板演示中解释清楚一切

0:30:40.533,0:30:44.000
但我们可以简化一下 PLONK 的结构

0:30:44.033,0:30:46.133
或者这些协议的结构

0:30:46.133,0:30:51.366
如果你看一下 PLONK 的证明

0:30:51.400,0:30:56.666
它的基本形式是一个承诺序列

0:30:56.666,0:31:01.133
比如 c₁, c₂, c₃ ，等等

0:31:01.133,0:31:08.533
以及一个计算序列， e₁, e₂, e₃ ，等等

0:31:08.533,0:31:11.600
这些方案还有别的内容吗？

0:31:11.633,0:31:12.633
我认为没有了

0:31:12.633,0:31:18.666
但我认为它们的基本结构是承诺和某些点的多项式求值

0:31:20.900,0:31:25.166
所以当我们看到这一点时，关键是

0:31:25.200,0:31:31.200
或者说一个启示是，如果这些东西看起来是随机的，
就更容易实现零知识

0:31:31.200,0:31:34.100
这些东西看起来越随机，零知识性就越强

0:31:34.700,0:31:40.700
如果你想象这些内容全都是完全均匀随机的，
那么它就是完全零知识的

0:31:40.733,0:31:44.333
Nico：是的。模拟器就可以直接生成随机内容

0:31:44.333,0:31:44.966
David：完全正确

0:31:45.000,0:31:47.333
作为模拟器，你只需选择随机值

0:31:47.333,0:31:47.500
Nico：不错。

0:31:47.533,0:31:50.933
David：但如果你这么做了，这个方案就不太可靠了

0:31:50.933,0:31:54.000
因为如果一切都是随机的，你怎么验证

0:31:54.033,0:31:56.633
Nico：因为我们仍然需要通过验证步骤，对吧？

0:31:56.633,0:31:57.500
David：对，没错

0:31:57.500,0:31:57.800
Nico：明白了。

0:31:57.833,0:32:00.700
David：但如果你通过选择随机值通过验证

0:32:00.700,0:32:04.833
那么证明者也可以这样做，那还有什么意义呢？

0:32:07.266,0:32:09.200
David：好吧。我们先看承诺部分

0:32:09.233,0:32:11.300
然后再看计算求值部分

0:32:11.833,0:32:14.366
有不同类型的承诺

0:32:14.400,0:32:19.600
比如 KZG 承诺、Pedersen 承诺，
还可以使用哈希等方式

0:32:19.600,0:32:24.500
在这里，为了让承诺看起来更随机

0:32:24.500,0:32:27.233
我们需要关注承诺的隐藏性（hiding property）

0:32:27.833,0:32:36.833
让我写一下——隐藏性承诺

0:32:36.833,0:32:39.300
承诺的隐藏性是什么意思呢？

0:32:39.300,0:32:42.600
顺便说一句，承诺必须是绑定的（binding）或者具有其他性质

0:32:42.633,0:32:44.466
但我这里不会讨论这些

0:32:44.466,0:32:46.766
我只会讨论隐藏性

0:32:46.800,0:32:52.000
隐藏性基本上意味着它看起来更随机，并隐藏了承诺的内容

0:32:52.733,0:32:56.033
还记得我们之前谈到的 Schnorr 协议中的承诺吗？

0:32:56.066,0:32:59.766
它通过在指数中隐藏内容

0:33:00.733,0:33:04.666
但在这里，我们会从更简单的承诺开始，比如哈希

0:33:08.633,0:33:09.500
Nico：是的。让我们从这里开始

0:33:09.500,0:33:15.100
David：想象一下，我想通过对一个值进行哈希来生成一个承诺

0:33:15.100,0:33:18.766
但这样做本身并不是特别安全

0:33:19.600,0:33:21.566
David：实际上，我问你个问题

0:33:21.600,0:33:23.533
你知道为什么这不是最佳的承诺吗？

0:33:23.533,0:33:25.333
Nico：从隐藏性的角度来看吗？

0:33:25.366,0:33:27.566
David：对，从隐藏性的角度

0:33:27.600,0:33:32.866
Nico：我猜每次我对相同的值 v 进行承诺，
我都会得到相同的承诺

0:33:32.866,0:33:34.166
David：确实如此

0:33:34.200,0:33:36.066
Nico：我猜，这在某种程度上是确定性的，对吧？

0:33:36.066,0:33:37.166
David：是的，这是确定性的

0:33:37.866,0:33:41.366
是的，如果你有两个承诺，并且你已经知道承诺的值

0:33:41.400,0:33:42.700
你可以区分它们

0:33:42.700,0:33:44.133
Nico：是的，这很有道理

0:33:44.133,0:33:46.533
David：你还能想到其他原因吗？

0:33:46.533,0:33:47.433
Nico：我猜——

0:33:47.466,0:33:48.200
David：有个好想法

0:33:48.200,0:33:55.433
Nico：如果我知道候选值，比如 v1 和 v2，
我可以对它们进行哈希以验证你使用了哪个值

0:33:55.433,0:33:56.533
David：对

0:33:56.533,0:33:58.866
因此，你可以自己尝试这些值

0:33:58.900,0:34:03.966
如果这些值在你可以尝试的范围内，你就能发现承诺的消息值

0:34:04.000,0:34:06.000
所以你基本上是对的

0:34:06.000,0:34:07.100
通过这些例子，我们可以清楚地看到

0:34:08.266,0:34:11.200
这样不能保证隐藏性

0:34:12.833,0:34:13.966
你还可以想到其他情况

0:34:14.000,0:34:17.566
比如，如果 v 非常小，你可以尝试所有的值，从 0开始

0:34:17.566,0:34:22.133
从 0 到 1 等等

0:34:22.133,0:34:24.233
那么我们如何解决这个问题呢？

0:34:24.266,0:34:30.966
基本上，我们可以通过附加一些随机性来解决这个问题

0:34:30.966,0:34:33.166
Nico：这个 r 和之前的 r 是一样的吗？

0:34:33.200,0:34:35.100
我猜，不是吧？

0:34:35.100,0:34:35.700
David：是的，不一样

0:34:35.700,0:34:36.966
Nico：是的，是的，我们把之前的擦掉

0:34:38.166,0:34:42.733
David：通过在哈希中添加一些随机性，你就不可能

0:34:42.766,0:34:47.000
计算哈希并检查它是否正确

0:34:47.033,0:34:48.433
因为你不知道那个随机性是什么

0:34:48.433,0:34:51.733
如果这个随机性足够大，那么

0:34:51.733,0:34:52.733
Nico：我就无法暴力破解，对吧？

0:34:52.766,0:34:54.133
David：你无法暴力破解

0:34:54.133,0:34:56.166
确实如此

0:34:57.633,0:34:59.533
Nico：所以现在，如果我对 v 进行多次承诺

0:34:59.533,0:35:03.733
每次都会有不同的随机性，
因此承诺每次都会不同，对吗？

0:35:03.733,0:35:05.366
David：完全正确

0:35:05.400,0:35:13.000
所以，每次你承诺时，你都会随机选择一个 r，
因此你会得到不同的随机承诺

0:35:13.000,0:35:15.500
在这里，如果你想象自己使用了一个哈希函数

0:35:15.500,0:35:18.133
那么这是一种真正隐藏它的方法

0:35:18.166,0:35:19.000
Nico：有道理

0:35:19.033,0:35:21.433
David：而这将

0:35:21.433,0:35:26.900
我们还可以讨论分布，但由于 r 是随机分布的

0:35:26.900,0:35:31.800
因此承诺也在整个空间中均匀分布

0:35:31.800,0:35:33.433
Nico：现在我们的模拟器会很高兴

0:35:33.466,0:35:34.366
David：没错

0:35:34.400,0:35:35.300
非常容易模拟

0:35:35.333,0:35:39.033
你只需选择随机值，这就可以了

0:35:39.033,0:35:43.933
Nico：你还向我们展示了
Schnorr 协议中的 g 的某个幂次形式的承诺

0:35:43.933,0:35:46.733
在这种情况下，我们如何对其进行随机化？

0:35:46.733,0:35:48.533
David：是的，g 的幂次形式

0:35:48.533,0:35:55.533
实际上，也许有一点之前我没有提到，但在我们的模拟器中

0:35:55.533,0:36:01.200
我们确实希望这些东西看起来像真实证明者的分布

0:36:01.800,0:36:08.133
因此，如果真实证明者的行为在域上是完全均匀分布的

0:36:08.133,0:36:10.133
那么构造一个模拟器就更容易了

0:36:10.133,0:36:15.433
因为你可以选择在同一域上均匀分布的东西

0:36:15.466,0:36:19.133
因此，我们将无法区分它们

0:36:19.133,0:36:23.200
但如果这些值分散开来

0:36:23.233,0:36:27.533
模拟器可以选择不同的值，不同的集合

0:36:28.066,0:36:33.400
那么这些集合就是不同的，这样区分器就更容易将它们区分开来

0:36:33.433,0:36:35.066
所以这是

0:36:35.066,0:36:38.366
当你构造一个模拟器时，这是你必须一直牢记在心的

0:36:38.400,0:36:45.300
你必须做一个与完美零知识中的真实证明者完全相同的集合

0:36:45.300,0:36:50.166
或者在统计零知识或计算零知识中几乎相同的集合

0:36:50.200,0:36:54.000
所以这里的点是，如果它是完全随机的，那么构造起来就更容易

0:36:54.000,0:36:54.966
如果它看起来是完全随机的

0:36:56.600,0:37:00.433
在我们的例子中，哈希就是这样，但这里不是，对吧？

0:37:00.433,0:37:01.533
Nico：是的。

0:37:01.533,0:37:06.633
David：所以Pedersen承诺在这里

0:37:10.433,0:37:14.700
David：Pedersen承诺其实非常简单

0:37:14.733,0:37:17.466
你只需要把它与另一个基数相乘

0:37:17.500,0:37:21.766
你不知道这个基数的离散对数，然后将其乘以r次方

0:37:21.800,0:37:22.600
这就是你的随机值

0:37:23.733,0:37:29.566
所以在这里，基本上，会返回群中的任何点

0:37:29.600,0:37:33.866
所以我们又回到了一个非常好的隐藏性质

0:37:33.866,0:37:38.000
Nico：看起来是随机的。好的

0:37:38.033,0:37:43.566
David：KZG承诺非常类似

0:37:45.233,0:37:49.366
只是因为效率问题，它用得不多

0:37:49.400,0:37:58.033
我们没有这种完美的隐藏性，所以必须做一些其他的随机化

0:37:58.033,0:38:01.766
Nico：所以我们可能会得到一些计算上隐藏的东西？

0:38:01.800,0:38:02.866
David：不是

0:38:02.866,0:38:03.500
Nico：不是，好的

0:38:03.500,0:38:06.700
David：因为我们有很好的随机化方式

0:38:06.733,0:38:09.300
所以我们还能得到完美的隐藏性

0:38:09.333,0:38:11.433
Nico：好的。所以我们现在已经

0:38:11.466,0:38:16.600
有了一种方法来隐藏我们的PLONK承诺

0:38:16.600,0:38:18.200
我们如何处理计算求值呢？

0:38:18.200,0:38:21.200
David：好的

0:38:21.233,0:38:23.666
这里我们讨论的不是值的承诺

0:38:23.666,0:38:25.733
而是多项式的

0:38:26.333,0:38:36.966
所以你得把多项式想象成是一个d次的多项式f，对吧？

0:38:37.000,0:38:38.500
这是我们在说的东西

0:38:38.500,0:38:39.300
Nico：是的

0:38:39.300,0:38:42.800
David：那么，如果你开始给出

0:38:42.833,0:38:46.500
如果我给你这个次数为 d 的多项式的计算求值

0:38:46.500,0:38:49.166
我就泄露关于多项式的信息了

0:38:49.200,0:38:52.500
实际上，问你一个问题

0:38:52.500,0:38:58.833
你需要多少个求值
才能恢复这个次数为 d 的多项式 f？

0:38:58.833,0:38:59.600
Nico：那应该是 d+1

0:38:59.600,0:39:00.666
David：对，d+1

0:39:00.700,0:39:03.533
根据定义，如果你有 d+1 个求值结果

0:39:04.533,0:39:06.433
你就可以完全描述这个多项式了

0:39:06.433,0:39:06.833
Nico：是的。

0:39:06.866,0:39:08.466
David：这就足够了

0:39:08.466,0:39:14.400
所以显然，我们不希望对同一个多项式
有 d+1 个求值结果

0:39:14.433,0:39:17.666
否则我们就完了

0:39:17.666,0:39:22.533
但即使是一个求值结果也已经够糟了，因为这个求值结果

0:39:22.533,0:39:27.466
这个评估结果实际上与多项式和证据数据紧密相关

0:39:27.500,0:39:30.933
因此，这可能会给我们的敌手带来一些优势

0:39:30.933,0:39:32.666
他们可能能够区分

0:39:32.700,0:39:35.966
Nico：那么现在，他们只需要再找到d个取值，
因为他们已经有1个了

0:39:36.000,0:39:39.100
如果他们想收集d+1个

0:39:39.100,0:39:40.233
我猜我们已经给了他们1个

0:39:40.233,0:39:44.966
对。但他们无法得到d+1个，不过也许1个就足以区分了

0:39:45.000,0:39:45.666
Nico：明白

0:39:45.700,0:39:48.533
David：因为他们只需要区分，对吧？他们不需要恢复f

0:39:48.866,0:39:50.600
David：他们只需要赢得这个游戏，对吧？

0:39:54.000,0:39:59.166
所以我们的思路是，将这些多项式随机化

0:39:59.166,0:40:00.366
Nico：这是什么意思？

0:40:00.366,0:40:01.766
David：这个意思是

0:40:01.800,0:40:03.100
我们基本上想要

0:40:03.100,0:40:07.900
因为如果我们把多项式随机化，那么我们就不会有相同的多项式了，对吧？

0:40:07.900,0:40:12.500
如果我们在多项式中加入随机性，那么它就会打乱协议

0:40:12.500,0:40:15.700
然后验证者就没有可以检查的东西了

0:40:15.700,0:40:18.333
所以这种随机化必须是受控的

0:40:18.333,0:40:24.600
它必须保留游戏的规则以及我们在PLONK中想要进行的身份验证

0:40:24.633,0:40:28.266
所以，这是一种，受控的随机化

0:40:28.266,0:40:29.566
Nico：好的

0:40:29.600,0:40:33.733
David：我不知道在这里需要回顾多少之前的内容

0:40:33.733,0:40:37.733
但在PLONK中，你有这些消失的（vanishing）多项式

0:40:37.733,0:40:44.333
我们在一个域上做运算，即电路的域，我们在那里选择了一些点

0:40:44.333,0:40:46.133
Nico：所以，也许我们可以把这个写下来

0:40:46.133,0:40:49.766
我们有单位根。我想这些在之前的课程中已经讲过了

0:40:49.800,0:40:50.533
David：好的

0:40:52.066,0:40:54.466
那么，假设我们有一个域H

0:40:54.466,0:41:03.366
这是由，比如说，g，我们的生成元，或者

0:41:03.366,0:41:05.233
Nico：我想他们在之前的课程中用的是Omega

0:41:06.766,0:41:08.200
Nico：如果这有帮助的话

0:41:11.800,0:41:19.500
所以你一定见过消失的多项式，你可以用简洁的方式写出来

0:41:20.333,0:41:23.866
我在这里写下H的大小，减一

0:41:24.700,0:41:31.333
所有的单位根，或者Omega单位根，在提升到它们域的大小

0:41:31.333,0:41:36.966
即它们群的阶数的幂时，会相互抵消

0:41:37.000,0:41:41.866
因此，我们得到了一个漂亮且简洁的多项式描述

0:41:41.866,0:41:43.400
也就是我们的消失多项式

0:41:43.433,0:41:48.366
David：如果这部分不清楚，我想大家可以回看之前的视频

0:41:48.400,0:41:49.066
Nico：是的

0:41:49.066,0:41:51.066
David：然后我们来看 f 是如何用的

0:41:51.100,0:42:00.800
假设在我们的 PLONK 或 STARK，或者其他协议中有一个多项式 f

0:42:00.833,0:42:04.700
我们想要创建一个随机化的 f'

0:42:04.700,0:42:10.866
我们要做的是让 f' 等于 f

0:42:10.900,0:42:24.600
就像之前那样，加上我们的消失多项式
乘以——我们暂时叫它 g，乘以 g(x)

0:42:24.600,0:42:27.066
Nico：要不要用个不同的字母，以避免冲突？

0:42:27.100,0:42:30.000
David：哦，是的。那用 m 吧

0:42:30.933,0:42:33.233
David：我们用 m(x)，好吧

0:42:33.266,0:42:35.900
我们来看一下

0:42:35.900,0:42:43.133
在我们的运算域中，仍然有 f'(x) 等于 f(x) 成立

0:42:43.166,0:42:46.200
Nico：也就是说，当我们在这些 Omega 点上进行求值时

0:42:46.200,0:42:49.566
David：在这些 Omega 或者 Omega 的幂次上，对吧？

0:42:50.133,0:42:52.633
David：因为这一部分在这些点上会是 0

0:42:52.633,0:42:53.333
Nico：对吧？

0:42:53.333,0:42:58.800
对吧？只要 x 等于某个 Omega 的幂， 右边的这一部分就消失了

0:42:59.400,0:43:00.233
David：是的，消失了

0:43:01.333,0:43:06.366
但是当我们不在这个域上，通常这里求值时

0:43:06.400,0:43:09.500
我们会在域外的点上计算这些多项式

0:43:09.500,0:43:10.133
Nico：对

0:43:10.133,0:43:14.400
David：不一定，但概率很高，足够高的概率

0:43:14.433,0:43:15.933
因为我们的域相对较小

0:43:17.700,0:43:22.300
然后，这部分会随机化我们的取值

0:43:22.300,0:43:24.033
Nico：那么在这种情况下，m 是什么？

0:43:24.066,0:43:29.100
David：在这种情况下，m 是一个随机多项式

0:43:29.100,0:43:41.000
比如 m(x) = r₀ + r₁X + r₂X²，依此类推

0:43:42.000,0:43:50.333
这里的随机值数量，或者那个随机多项式m的次数

0:43:50.333,0:43:52.733
是由求值的数量决定的

0:43:52.733,0:43:57.000
所以，求值越多，得到随机性就越大

0:44:00.733,0:44:04.566
我想证明这有效的方法有很多种

0:44:05.800,0:44:10.700
也许有效的方法之一是，如果你在某个点计算这个，比如说

0:44:10.700,0:44:16.433
你在两个点上计算 f'，你会发现你可以

0:44:16.466,0:44:24.466
我们有 f'(α₁) 和 f'(α₂)

0:44:24.466,0:44:30.066
如果你在两个点上计算它 你会发现

0:44:30.933,0:44:35.533
如果你给它们任意你想要的值

0:44:35.533,0:44:40.966
你会发现你可以得到

0:44:41.000,0:44:43.333
你基本上有一个方程组

0:44:44.733,0:44:48.666
如果你有足够的随机值，比如说两个

0:44:49.400,0:44:56.800
你有两个未知数，在一个线性独立方程组中

0:44:56.800,0:44:58.533
有两个线性独立的方程

0:44:58.533,0:45:00.000
因此，你可以解出来

0:45:00.033,0:45:00.700
Nico：明白

0:45:00.700,0:45:02.366
David：我不知道是不是说明白了

0:45:02.400,0:45:05.666
但这是你可以尝试理解它的一种方式

0:45:05.666,0:45:07.100
我试着换个方式表达

0:45:07.100,0:45:13.766
但如果你有两个——如果你有一个1次多项式

0:45:13.800,0:45:16.100
如果你有两个随机系数

0:45:16.100,0:45:20.100
那么对于任意两个点，你都可以得到你想要的任何评估值。

0:45:20.100,0:45:22.966
所以，如果你有更多的评估次数，你就需要更多的随机系数

0:45:23.000,0:45:28.866
那么，我最后一个问题是，这个 f' 多项式的总次数是多少？

0:45:29.533,0:45:36.000
因为在这里加了一些东西，我们提高了这个多项式的次数

0:45:37.033,0:45:47.633
所以 f 很可能已经达到消失多项式的次数了

0:45:49.100,0:45:52.633
只是因为PLONK或者我们出于某种原因加上去的

0:45:52.666,0:45:53.666
Nico：当然

0:45:53.666,0:46:00.500
David：但这里的m是求值的个数减一

0:46:00.500,0:46:01.566
Nico：减一

0:46:01.600,0:46:02.233
David：对

0:46:02.233,0:46:07.466
因为如果你进行两次求值，你就会得到一个1次多项式

0:46:07.466,0:46:09.500
所以

0:46:09.500,0:46:14.033
基本上，你是在做乘法，所以如果这个是n次

0:46:14.066,0:46:17.866
那么进行两次求值后，你就会得到n+2次

0:46:17.866,0:46:28.166
这在增加多项式次数——可能会有d+2，d+3次，或者类似的情况

0:46:28.200,0:46:31.466
增加次数可能会很麻烦

0:46:31.466,0:46:32.066
Nico：对。

0:46:32.066,0:46:34.733
因为这对证明者和验证者来说都是一种成本

0:46:34.733,0:46:37.100
David：是啊。基本上是这样

0:46:37.133,0:46:39.433
Nico：好，我们来看看KZG怎么样？

0:46:39.433,0:46:40.600
David：好啊

0:46:40.633,0:46:44.233
我们之前谈过Pedersen中的哈希

0:46:44.233,0:46:47.300
现在我们简单提一下KZG

0:46:48.133,0:46:52.033
KZG的承诺方式是不同的

0:46:52.066,0:46:54.166
我想，在之前的课程中已经讲过了

0:46:54.900,0:46:59.500
David：所以，对函数的承诺基本上就是

0:46:59.500,0:47:02.433
在某个秘密点上对该函数的承诺

0:47:02.466,0:47:06.333
我应该——用Tau来表示

0:47:07.933,0:47:11.033
所以并没有

0:47:11.066,0:47:14.666
揭露一些信息，尤其是面对一个无限能力的攻击者时

0:47:14.666,0:47:15.733
Nico：对。这很有道理

0:47:15.733,0:47:19.766
David：当你试图进行这些证明时，你实际上是在解离散对数

0:47:19.800,0:47:23.833
所以，如果攻击者是无限能力的，他们就可以轻易地看到这一点。

0:47:23.833,0:47:27.000
Nico：所以我们揭露了f的一个求值

0:47:27.000,0:47:30.100
David：对。那么，隐藏它的方法是什么？

0:47:30.100,0:47:31.600
Nico：就像我们之前做的那样

0:47:31.633,0:47:32.166
David：没错

0:47:32.200,0:47:33.866
Nico：添加更多

0:47:33.866,0:47:38.933
你只需要在这个掩盖的多项式中 添加更多随机性

0:47:38.933,0:47:41.333
没什么特别的

0:47:41.333,0:47:43.233
是的，你把它看成一个取值

0:47:44.333,0:47:46.200
也许值得一提的是

0:47:46.233,0:47:51.300
PLONK 可以用 KZG 或别的承诺来实例化

0:47:51.300,0:47:53.566
Mina 使用的是 Pedersen 承诺

0:47:53.600,0:47:55.300
因此，使用不同的承诺方案

0:47:55.300,0:47:58.200
你会得到不同的隐藏多项式，但它们的次数也不同

0:47:58.233,0:48:01.766
Nico：是的。我还有一个问题是

0:48:01.800,0:48:05.033
当我们使用 KZG 时，我们有一个可信初始化设置（trusted setup）

0:48:06.500,0:48:11.000
在这个流程中可信初始化设置发生在什么阶段？ 这是否重要？

0:48:13.066,0:48:17.500
正如我所说，我们仍然希望通过模拟器来生成这些证明以证明 ZK，

0:48:17.500,0:48:22.566
我们仍然关心完美、统计或计算的零知识，以及所有这些内容

0:48:22.600,0:48:24.200
所以这基本上是相同的

0:48:24.200,0:48:26.233
也就是说，我们仍然在那个模型中

0:48:26.233,0:48:31.033
只不过我们多了一个步骤，需要创建可信初始化设置

0:48:31.033,0:48:34.066
就是 KZG 的 Tau。

0:48:35.466,0:48:37.100
那么它通常在哪一步设置呢？

0:48:37.100,0:48:47.133
基本上，模拟器在这里将创建 CRS 或 SRS（让我们称为 SRS，结构化参考字符串）

0:48:48.100,0:48:51.833
并输出那个“陷门”

0:48:53.200,0:48:54.633
我要滥用一下符号了

0:48:54.633,0:48:57.233
通常你会先选择 b

0:48:57.233,0:49:01.300
如果你是证明者，你会有一个普通的 SRS

0:49:01.300,0:49:04.433
如果你在模拟器的设置中

0:49:04.466,0:49:08.066
那么模拟器可以创建 SRS，可能会有所不同

0:49:08.066,0:49:12.866
因此，区分者可能能够看出 SRS 看起来不同

0:49:12.866,0:49:14.733
这是可能的

0:49:14.733,0:49:21.633
所以，我有点滥用符号了，但请记住 SRS 在这里可能是不同的。

0:49:22.633,0:49:24.166
这是我们的“有毒废料”吗？

0:49:24.200,0:49:24.800
David：哦，对

0:49:24.800,0:49:26.000
这是有毒废料

0:49:26.000,0:49:27.233
这就是“陷门”

0:49:27.233,0:49:29.600
这是秘密点

0:49:30.233,0:49:38.266
所以现在模拟器有了一些额外的能力，可以利用 Tau 的知识

0:49:38.266,0:49:41.766
Nico：有意思。那么它也会出现在这里？

0:49:41.800,0:49:42.900
David：完全正确

0:49:43.533,0:49:46.000
David：所以我们会在这里添加 Tau

0:49:46.033,0:49:50.866
实际上，如果你查看 PLONK 的零知识证明及类似方案

0:49:50.866,0:49:53.333
它们并不真正关心挑战值的选择

0:49:54.400,0:49:57.600
因为它们已经有足够的能力可以直接使用“陷门”。

0:49:57.600,0:50:01.900
这很有道理。那么在这里这些的顺序是怎么样的呢？

0:50:01.900,0:50:08.100
是否总是攻击者在 SRS 存在之后选择witness和证据？

0:50:08.100,0:50:08.566
David：对。

0:50:08.600,0:50:14.666
好吧，也许我们可以提一下，但这里有自适应和非自适应版本

0:50:14.666,0:50:17.200
我们有许多零知识的变体

0:50:17.200,0:50:17.433
Nico：当然。

0:50:17.466,0:50:23.066
David：但在这里，模拟器有机会在选择SRS之前

0:50:23.800,0:50:26.300
或者没有机会（选择SRS）

0:50:26.300,0:50:28.533
在看到witness和实例之前

0:50:28.533,0:50:34.033
所以这被称为自适应模型，因为对手可以看到SRS

0:50:34.066,0:50:35.900
并且可以适应它

0:50:35.933,0:50:36.633
Nico：这有点道理

0:50:36.633,0:50:41.600
但如果这是在之前发生的，那么我们就会说这是非自适应模型

0:50:41.633,0:50:45.933
因为对手会被限制在一个证据和一个实例中

0:50:45.933,0:50:49.166
然后模拟器可以看到那个

0:50:49.200,0:50:53.300
所以模拟器会看到——哦，不是witness

0:50:53.400,0:50:59.666
在非自适应模型中，模拟器会看到实例

0:50:59.866,0:51:02.466
Nico：是的，没错

0:51:05.733,0:51:12.366
我们需要记住的是，我们希望给区分器尽可能多的能力

0:51:12.400,0:51:17.433
或者换句话说，区分器能力越强，证明就越好

0:51:17.433,0:51:21.966
Nico：总结一下这个性质

0:51:22.000,0:51:24.233
我们之前提到，因为攻击者是有能力限制的

0:51:24.233,0:51:29.100
所以拥有计算零知识是可以接受的

0:51:29.100,0:51:33.833
自适应是我们肯定想要的，
因为我们的可信初始化设置已经存在了

0:51:33.866,0:51:38.566
或者更像是，你希望将这种能力赋予攻击者

0:51:39.533,0:51:42.000
能抵御更强能力的攻击者，说明证明更好

0:51:42.033,0:51:43.166
Nico：对的

0:51:43.200,0:51:46.233
但我不是说——计算零知识是我们可以接受的

0:51:46.233,0:51:48.833
但通常来说，完美零知识性会更好。

0:51:48.866,0:51:51.400
David：或者统计的也更好。就像这两种——

0:51:51.433,0:51:56.866
Nico：我想表达的是，在实际协议中，我们会得到什么？

0:51:56.866,0:52:03.600
如果我对我的 PLONK 承诺进行隐藏，并对取值进行掩盖

0:52:04.300,0:52:06.200
我们会得到哪种零知识类型？

0:52:06.233,0:52:09.833
David：通常你会得到统计零知识

0:52:10.400,0:52:14.500
而且我的理解是，这主要是因为

0:52:14.500,0:52:19.500
它不是完美的，因为在某些点上，证明副本可能会出问题

0:52:20.433,0:52:23.866
比如，如果求值点在你的域中

0:52:23.900,0:52:25.633
这些就不成立了

0:52:25.666,0:52:28.433
就像有些极端情况证明可能会失败，但这是可以忽略的概率

0:52:28.433,0:52:30.366
这就是为什么我们称其为统计型零知识

0:52:30.400,0:52:31.800
Nico: 有道理

0:52:32.266,0:52:37.033
但结果证明，最近有关于PLONK和ZK（零知识证明）的结果

0:52:37.033,0:52:43.633
表示，PLONK达到的并不是统计意义上的ZK

0:52:43.633,0:52:45.700
也许它是计算的ZK，我们不知道

0:52:46.233,0:52:47.966
但已经证明它不是统计ZK

0:52:48.000,0:52:49.466
只需要一个小修正

0:52:50.300,0:52:52.733
我想这可能是几年前就发现的

0:52:52.733,0:52:56.400
但直到最近才发表，并且在原论文中进行了修正

0:52:57.200,0:53:00.300
Nico：已经修正了，所以

0:53:00.300,0:53:04.633
修正后的论文又回到了统计零知识

0:53:04.633,0:53:05.033
David：对

0:53:05.066,0:53:08.166
所以现在我们有了统计的ZK PLONK

0:53:09.033,0:53:14.466
也许还值得一提的是，关于PLONK，基本上所有相关论文都出来了

0:53:14.466,0:53:18.466
实际上，PLONK做得更好，因为他们说明了如何实现ZK

0:53:18.466,0:53:20.600
很多论文甚至都没有提到如何实现ZK

0:53:20.600,0:53:23.500
它们只是留给读者自己去练习

0:53:23.533,0:53:26.433
Nico：好吧。那只能自己写模拟器了

0:53:26.433,0:53:27.533
David：对

0:53:27.533,0:53:28.666
自己去做证明

0:53:28.700,0:53:29.833
但不完全是模拟器，对吧？

0:53:29.866,0:53:32.200
就像是我该如何在我的方案中添加ZK呢？

0:53:32.233,0:53:33.133
Nico：对

0:53:33.166,0:53:37.133
David：至少PLONK告诉了你如何添加ZK。只是他们没有提供证明

0:53:37.133,0:53:44.600
所以这就是关键。没有证明，或者至少它不是统计的ZK

0:53:44.600,0:53:45.966
Nico：是的

0:53:46.000,0:53:51.466
David：我可以稍微谈一下这个

0:53:54.866,0:54:00.133
在白板上解释这个有点难，尤其是PLONK很复杂

0:54:00.133,0:54:03.200
但也许我可以谈谈这个攻击背后的一些直觉

0:54:08.866,0:54:10.600
我们不想写模拟器

0:54:10.633,0:54:14.166
如果我们能写模拟器，那么我们就证明了它是ZK

0:54:17.200,0:54:19.600
所以我们想写的是一个攻击者

0:54:19.600,0:54:26.400
但我要写一个不同类型的攻击者，因为

0:54:26.400,0:54:30.133
他们所做的并不是证明它不是ZK

0:54:30.133,0:54:35.533
他们所做的是证明它不是“证据不可区分”的

0:54:35.533,0:54:39.433
这是一个不同的、更弱的性质

0:54:39.466,0:54:42.600
如果不满足这个性质，就不是零知识的

0:54:42.633,0:54:45.066
如果是ZK的，就满足这个性质。如果没有这个性质，就不是ZK

0:54:45.066,0:54:47.300
Nico：嗯

0:54:47.300,0:54:53.933
非正式地说，证据不可区分性是——你有两个证据

0:54:53.933,0:54:56.600
所以攻击者或是验证者产生了两个证据

0:54:57.600,0:55:00.366
然后他们把这些证据给你，你是证明者。

0:55:00.700,0:55:03.500
David：然后你随机选择，或者你喜欢的任何方式

0:55:03.500,0:55:06.566
最有可能是随机地，选择你想要证明的witness

0:55:07.600,0:55:09.000
然后你把它发给我

0:55:09.000,0:55:15.700
如果我能猜出我给你两个证据中的哪一个是你证明的，那么你就不满足这个性质

0:55:17.233,0:55:22.733
所以他们针对一个非常简单的电路演示了这种攻击

0:55:22.733,0:55:30.433
基本上，PLONK中的问题是你有这个商多项式T

0:55:31.466,0:55:39.766
它被掩盖了，实际上是没问题的，但他们实际上把它用T₁分成了几部分

0:55:39.800,0:55:41.800
Nico：T low, T mid 和 T high，对吧？

0:55:41.800,0:55:42.433
David：对，没错

0:55:42.433,0:55:46.666
我就这样写。所以T(x)实际上被分割了，因为它太大了

0:55:47.300,0:55:59.000
所以可以得到T low + Xⁿ 乘以 T mid + X²ⁿ 乘以 T high，是这样吗？

0:55:59.000,0:56:01.100
Nico：是的

0:56:01.100,0:56:09.000
David：因为像这样拆分了之后，PLONK没有掩盖这些多项式

0:56:09.033,0:56:12.833
这三个多项式泄露了一些信息

0:56:12.833,0:56:15.400
Nico：对，因为这些多项式是分开承诺的，对吧？

0:56:15.433,0:56:15.800
David：没错

0:56:15.800,0:56:19.633
Nico：然后我们又回到了上面的问题

0:56:19.666,0:56:21.133
David：我们又回到了这个问题上

0:56:21.133,0:56:27.866
如果我记得没错的话，如果用他们的例子写出方程

0:56:27.900,0:56:33.133
这里就是一个门和单位置换

0:56:33.133,0:56:37.233
这是一个非常简单的例子，但它可以推广

0:56:37.266,0:56:41.666
基本上你可以看到T low和T mid之间的关系

0:56:41.666,0:56:45.333
当你分析证明副本时，它们之间存在某种关系

0:56:45.333,0:56:50.800
如果你能根据第一个证据或第二个证据发现这种关系

0:56:50.833,0:56:53.166
你就能区分它们

0:56:53.200,0:56:56.266
所以简单的解决办法就是像我们之前那样掩盖它们

0:56:56.266,0:56:56.800
Nico：就像我们做的那样

0:56:56.800,0:56:57.633
David：就像我们看到的

0:56:58.633,0:56:59.133
前面写的

0:56:59.166,0:57:01.066
Nico：非常好
David：是的

0:57:02.466,0:57:05.933
Nico：这样就结束了吗？

0:57:05.933,0:57:06.466
David：是的。

0:57:06.500,0:57:08.866
如果你们还有其他问题，我很乐意回答

0:57:08.900,0:57:11.466
Nico：也可以快速总结一下我们这些内容

0:57:11.466,0:57:12.166
David：好的

0:57:12.200,0:57:15.666
所以ZK重不重要取决于方案

0:57:15.666,0:57:18.000
有时候你只关心简洁性

0:57:18.033,0:57:20.033
ZK有不同的类型

0:57:20.033,0:57:23.866
我们喜欢完美零知识性，但我们有完美、统计和计算这三种

0:57:23.866,0:57:26.966
这些都不错，要看具体情况

0:57:27.000,0:57:33.700
正如我们所见，使用PLONK和其他方案时，我们通常得到的是统计ZK

0:57:33.700,0:57:37.900
我们谈到了不诚实验证者和诚实验证者

0:57:37.900,0:57:41.366
不诚实验证者也没关系

0:57:41.400,0:57:47.133
因为我们通常在非交互环境下使用Fiat-Shamir变换

0:57:47.133,0:57:53.866
我们还谈到了自适应和非自适应模型

0:57:53.900,0:58:00.533
我们更喜欢自适应模型以及这类东西

0:58:00.533,0:58:06.000
我想我们在这里谈到了这两件事，模拟器和如何隐藏信息

0:58:06.700,0:58:09.233
所以设计模拟器是我们构造证明的方式

0:58:09.266,0:58:13.866
模拟器根据不同的模型具有不同的能力

0:58:13.866,0:58:16.066
也许它们可以询问验证者

0:58:16.066,0:58:22.066
但它们其实并不需要，因为它们知道验证者会做什么

0:58:22.066,0:58:27.733
或者它们需要猜测，设定里是诚实的还是不诚实验证者

0:58:27.733,0:58:29.866
我们还看到了具有隐藏性的承诺

0:58:29.900,0:58:35.500
所以在KZG或Pedersen或哈希中，我们如何才能真正让它看起来是随机的

0:58:35.500,0:58:42.133
或者即使在计算求值的情况下也能得到随机分布？

0:58:42.133,0:58:48.366
那么我们如何才能让这些取值看起来是随机的，并且不泄露任何信息呢？

0:58:48.400,0:58:52.466
最后，我们提到PLONK并不是统计上的零知识

0:58:52.466,0:58:53.300
Nico：这个小问题已经解决了

0:58:53.300,0:58:53.833
David：是的

0:58:53.866,0:58:56.000
因为他们忘了掩盖这些多项式

0:58:56.033,0:58:59.766
Nico：我想补充一点，这点非常重要

0:58:59.800,0:59:05.600
我见过很多次这样的错误，有的人认为对信息做哈希就能使其保密

0:59:05.600,0:59:10.200
但这是不对的，因为那就变成了一个确定性的承诺

0:59:10.200,0:59:14.233
所以你得到的只是数据的某种“指纹”

0:59:14.233,0:59:20.900
所以，我希望大家能注意这一点，并记住它

0:59:20.900,0:59:21.366
对的

0:59:21.400,0:59:26.033
我想现在大家可以说自己掌握零知识了，而不是只了解ZK这个缩写

0:59:27.633,0:59:28.866
感谢你的讲解

0:59:28.866,0:59:29.366
David：好的

0:59:29.400,0:59:30.933
谢谢你们的邀请