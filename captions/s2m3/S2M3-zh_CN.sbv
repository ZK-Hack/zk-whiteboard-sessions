0:00:07.000,0:00:10.000
S2模块3：与Ariel Gabizon一起聊聊Lookups的最新进展

0:00:10.815,0:00:14.320
Nico：欢迎来到这个模块 ZK Whiteboard Sessions 

0:00:14.320,0:00:16.400
今天我们将聊一聊 lookups 的最新进展 

0:00:16.400,0:00:20.960
这是第6模块,第1季与Mary Maller一起分享的后续 

0:00:20.960,0:00:24.400
我是Nico 我将成为今天的主持 
今天和我一起的是Ariel Gabizon 

0:00:24.400,0:00:25.100
你好，Ariel！

0:00:25.100,0:00:26.580
Ariel：嘿！很高兴来到这里 

0:00:26.580,0:00:29.000
Nico：所以，Ariel，今天的计划是什么？

0:00:29.000,0:00:35.280
Ariel：今天我要开始为大家讲述lookup的概述 

0:00:35.280,0:00:36.160
不同的

0:00:36.160,0:00:40.960
三种已在lookup协议中使用的主要方法 

0:00:40.960,0:00:44.640
然后我们将深入研究其中一种方法

0:00:44.640,0:00:47.260
可以称为“log derivative”方法 

0:00:47.260,0:00:49.100
Nico：酷我们可以开始吗？

0:00:49.100,0:00:51.320
Ariel：是的 我们开始吧！

0:00:51.320,0:00:59.920
因此，让我们看一下lookup的范畴 

0:01:02.880,0:01:12.960
我们可以想到三种主要的已被使用的lookup协议 

0:01:12.960,0:01:21.400
首先是我们有“multiset equality based” 

0:01:21.400,0:01:23.480
Nico：好的 

0:01:23.480,0:01:38.000
Ariel：在此类别中，我们有比如 Halo 2 lookup协议，Plookup协议，

0:01:38.000,0:01:46.240
稍微不知名一点的的是,基于 

0:01:47.360,0:01:56.280
内存检查的协议在Spartan论文上 

0:01:57.080,0:02:06.708
最近，GKR版本出现在Lasso中 

0:02:06.708,0:02:10.480
Nico：好的 所以，Halo 2和Plookup是我们在模块6中看到的那种,对吗？

0:02:10.480,0:02:13.280
Ariel：没错 是的 

0:02:13.280,0:02:21.520
第二种方法是人们通常称为基于“log derivative” 

0:02:24.960,0:02:29.720
坦白讲，这是一个不太形象的名称，

0:02:29.720,0:02:34.600
但这是有历史原因的 

0:02:35.360,0:02:41.480
从某种意义上说，这个根源是log derivative的来源可能是

0:02:41.480,0:02:45.200
最原始lookup协议也就是来自ARIA论文的协议，

0:02:45.880,0:02:53.160
但是也许更具描述性的名称是只是基于fractional sums的lookups 

0:02:53.160,0:02:54.840
Nico：好的 

0:02:55.880,0:02:59.840
我们需要了解什么是log derivative才能理解这些吗？
还是说不需要？

0:02:59.840,0:03:01.960
Ariel：不需要 这正是它的妙处 

0:03:01.960,0:03:09.474
您可以谈论log derivative lookup的同时
完全不知道什么是log derivative 

0:03:09.474,0:03:10.673
Nico：这更具描述性 对吗？

0:03:10.673,0:03:15.480
Ariel：基本上是sums of fractions，我们将稍后再看到 

0:03:15.480,0:03:24.280
在这个类别中，我们还有 你能说的是经典的

0:03:24.280,0:03:25.480
今天的人们这么称它

0:03:25.480,0:03:34.320
logUp协议，最初出现在Eagen等人的Bulletproof++的论文中 

0:03:34.320,0:03:39.400
但是，我认为这个话题的标准参考文献是

0:03:39.400,0:03:46.502
Haböck在此协议上的这项独立工作 

0:03:46.502,0:03:46.513
Nico：好的 

0:03:46.513,0:03:54.340
所以我们有logUp然后我们有了CQ协议 

0:03:54.340,0:03:56.020
Nico：你是其中一位作者吗？

0:03:56.020,0:03:56.960
Ariel：是的 

0:03:56.960,0:04:04.020
logUp，或者您可以说调整logUp到适应非常大的表 

0:04:04.020,0:04:04.860
Nico：好的 

0:04:04.860,0:04:20.160
Ariel：我们有一些变体CQ+，CQ ++和M-Seek 

0:04:20.160,0:04:24.893
Nico：一些经典的密码学命名在这里 

0:04:24.893,0:04:25.760
Ariel：是的 
Nico：很多+和++ 

0:04:27.720,0:04:28.140
哈哈 

0:04:28.140,0:04:29.080
Ariel：是的 

0:04:29.080,0:04:33.280
还有 

0:04:33.280,0:04:45.440
而且在这里人们一直在努力使用GKR
加快logUp协议的某些方面 

0:04:46.400,0:04:48.420
所以，这是第二种方法 

0:04:48.920,0:04:56.780
Ariel：第三种方法，我们可以称其为基于“matrix-vector” 

0:04:56.780,0:04:58.640
Nico：好的 

0:04:58.640,0:05:03.960
Ariel：基于“矩阵矢量乘法” 

0:05:04.680,0:05:06.800
我认为第一个

0:05:06.800,0:05:12.480
在这个语境下第一个lookup是Baloo的工作 

0:05:15.920,0:05:23.902
在一定程度上，Lasso的某些组件也属于这种方法 

0:05:23.902,0:05:23.913
Nico：好的 

0:05:23.913,0:05:34.520
Ariel：在folding的预警下，我们有FLI，最近的一篇论文 

0:05:34.520,0:05:40.560
哦，我有点忘了说把log derivative方法

0:05:40.560,0:05:47.440
用于folding也是在ProtoStar的论文中 

0:05:47.440,0:05:51.240
Nico：这个在folding模块中有提到 

0:05:51.240,0:05:53.240
这是一个不错的关联 

0:05:53.240,0:05:57.680
酷所以我们有

0:05:57.680,0:05:59.840
我们有这三种方法 

0:05:59.840,0:06:01.360
这并不全面 

0:06:02.800,0:06:09.960
有些论文在这里没有提到，可能也不完全符合这些类别 

0:06:11.320,0:06:17.800
但是无论如何，今天我们要去专注于log derivative方法

0:06:17.800,0:06:24.480
并深入研究不同的变体，不同的版本 

0:06:24.480,0:06:26.860
Nico：听起来不错 我们应该开始吗？

0:06:26.860,0:06:29.680
Ariel：是的！让我们开始吧 

0:06:29.680,0:06:35.920
因此，让我擦掉它 

0:06:35.920,0:06:38.800
好的 所以让我们深入研究log derivative的方法 


0:06:44.890,0:06:58.000
Ariel：方法是基于遵循如下所示的基本引理 

0:06:58.000,0:07:04.640
假设 - 让我们固定向量f和n，它们的长度为n，在域上 

0:07:04.640,0:07:06.760
所以再次强调，我们将其视为表 

0:07:06.760,0:07:09.600
这是我们的witness 我们希望证明它包含在表中 


0:07:10.350,0:07:18.880
Ariel：让我们假设该域的特征大于n 

0:07:18.880,0:07:22.100
Nico：该域的特征是什么？

0:07:22.100,0:07:26.360
Ariel：域的特征是你可以把反复把1加到它本身

0:07:26.360,0:07:30.520
使得和为零的最少的次数 

0:07:30.520,0:07:33.020
Nico：是我们域的元素数量吗？

0:07:33.020,0:07:36.702
Ariel：嗯，怎么说呢，在素数域
大小为素数的域里是这样的没错 

0:07:36.702,0:07:36.713
Nico：好的 

0:07:36.713,0:07:43.000
Ariel：但是在例如域的大小为2的次方的域里
这些领域最近变得流行 

0:07:43.000,0:07:46.660
那么特征会是2，即使这些域的大小可能是2^128 

0:07:46.660,0:07:48.600
Nico：我明白了 好的 

0:07:48.600,0:07:54.600
Ariel：所以引理给我们一些lookup的标准 

0:07:54.600,0:08:05.880
它说f包含在t中当且仅当存在大小为n的向量m

0:08:05.880,0:08:18.680
使我们有以下有理函数的等式 

0:08:18.680,0:08:21.080
所以等式看起来像这样 

0:08:21.080,0:08:27.840
在左侧，我们有从1到n的求和 

0:08:27.840,0:08:29.440
Nico：好的 

0:08:29.440,0:08:38.040
Ariel：x 加tᵢ分之mᵢ 

0:08:38.040,0:08:45.200
所以有点像整个表的分数和按mᵢ加权 

0:08:45.200,0:08:45.950
Nico：好的 

0:08:45.950,0:08:50.440
Ariel：在右侧我们有

0:08:50.440,0:08:55.720
一个关于f的分数和或者说是witness

0:08:55.720,0:08:59.280
您可以这么想它

0:08:59.280,0:09:02.200
Nico：好的 这个等式告诉我们了什么？

0:09:02.200,0:09:05.580
它如何链接到我们的lookup问题？

0:09:05.580,0:09:07.000
Ariel：嗯呢 

0:09:07.000,0:09:12.640
嗯，所以我们在这里声称m的存在

0:09:12.640,0:09:17.500
从而导致这个式子成立，这是一个loopup的等价条件 

0:09:17.500,0:09:18.180
Nico：好的 

0:09:18.180,0:09:25.640
Ariel：为了得到一些直觉，让我们至少起草一下证明 

0:09:25.640,0:09:34.400
嗯，比较容易一点的证明方向是必要的条件 

0:09:34.400,0:09:38.880
让我们假设f包含在t中 

0:09:38.880,0:09:40.560
让我们做这个小练习 

0:09:40.560,0:09:41.250
Nico：当然 

0:09:41.250,0:09:47.760
Ariel：我们应该如何取mᵢ使得这个等式成立呢？

0:09:47.760,0:09:52.633
Nico：让我们看看 所以这是一个乘数，对吗？

0:09:52.633,0:09:52.740
Ariel：对 

0:09:52.740,0:09:57.680
Nico：我们是说mᵢ是出现fi的次数，

0:09:57.680,0:10:00.200
或者tᵢ出现在f中的次数？

0:10:00.200,0:10:01.480
Ariel：没错！对的 

0:10:01.480,0:10:18.820
我们只需要取mᵢ等于j的数量，使得fj等于tᵢ 

0:10:18.820,0:10:21.800
Nico：好的 

0:10:21.800,0:10:23.360
因此，这是重复的数量 

0:10:23.360,0:10:25.234
Ariel：没错 不是吗？

0:10:25.234,0:10:27.220
Nico：f出现在t中的元素  

0:10:27.220,0:10:27.680
Ariel：对 

0:10:27.680,0:10:34.720
如果每个索引，每个索引 此fi是t的元素

0:10:34.720,0:10:38.960
我们只是将这些mᵢ取为重复的数量 

0:10:38.960,0:10:44.200
对吧？然后，显然我们会得到这个等式 

0:10:45.160,0:10:46.200
好的 

0:10:46.200,0:10:50.160
现在更有趣是另一个方向 

0:10:50.160,0:10:53.080
让我们起草它 

0:10:53.080,0:10:56.760
Nico：当然 

0:10:56.760,0:10:59.240
Ariel：所以让我在这里做 

0:11:00.120,0:11:02.660
Nico：当然 让我搬到另一边 

0:11:02.660,0:11:05.280
Ariel：好的 

0:11:06.360,0:11:12.840
好的 所以现在让我们假设f不包含在表中 

0:11:12.840,0:11:20.314
因此，右侧存在

0:11:20.314,0:11:22.360
Nico：某些出现零次的东西 

0:11:22.360,0:11:22.760
Ariel：没错 

0:11:22.760,0:11:24.320
存在一些

0:11:24.320,0:11:33.740
在这里，有被求和项x + a分之1，其中a不在里t里面 

0:11:33.740,0:11:34.960
Nico：好的 

0:11:34.960,0:11:39.080
Ariel：所以现在问题是 我们在这里有这个被求和项 

0:11:39.080,0:11:45.800
我们可以以某种方式选择mᵢ 从而得到这个被求和项吗？

0:11:45.800,0:11:46.480
Nico：没错 

0:11:46.480,0:11:49.040
因此，假装它存在于此 

0:11:49.040,0:11:49.960
Ariel：是的 

0:11:49.960,0:11:59.280
基本上这个想法是

0:11:59.280,0:12:07.800
如果我们查看所有这些函数的集合
函数x + b分之一上的函数1，b可以取域上的任意数

0:12:09.680,0:12:16.800
因此，你可以验证这些函数是线性独立的 

0:12:16.800,0:12:22.660
Nico：所以没有线性组合可以组合出一个这里不存在的元素 

0:12:22.660,0:12:23.080
Ariel：是的 

0:12:23.080,0:12:29.280
所以如果这个a不是在t中，没有线性组合

0:12:29.280,0:12:33.880
在左侧可以给我们这个元素 


0:12:35.160,0:12:46.820
所以我们不能在x上构造x+a分之1 在左侧

0:12:46.820,0:12:51.440
Nico：好的 那就是为什么我们使用这些有理函数，

0:12:51.440,0:12:52.660
因为他们有这个属性？

0:12:52.660,0:12:53.800
Ariel：完全正确 

0:12:53.800,0:12:58.680
这些函数的线性独立性是主要因素之一

0:12:58.680,0:13:03.000
这使它们如此方便和有用 

0:13:03.000,0:13:08.520
所以你可能想知道这个特征在哪有用？

0:13:08.520,0:13:19.520
假设我们有这样的元素a，但是特征是2 

0:13:19.520,0:13:20.600
Nico：好的 

0:13:20.600,0:13:24.200
Ariel：那么，我们怎么能作弊？

0:13:24.200,0:13:29.120
好吧，假设现在我们尝试使用向量

0:13:29.960,0:13:34.280
f，这个没在表中的元素a出现两次 

0:13:35.280,0:13:38.240
那将会发生什么，在这个右侧？

0:13:38.240,0:13:39.920
Nico：他们会消掉吗？

0:13:39.920,0:13:40.680
Ariel：没错 

0:13:40.680,0:13:42.150
Nico：好的 

0:13:42.150,0:13:46.800
Ariel：所以，尽管我们有一个不在表中的元素，

0:13:47.480,0:13:49.640
因为特征很小，所以

0:13:51.080,0:13:56.640
该元素在这一侧的贡献会被削掉，prover因此可以作弊 

0:13:56.640,0:13:57.300
Nico：我明白了 

0:13:57.300,0:14:00.520
Ariel：好的 所以现在我们有了基本的引理，

0:14:00.520,0:14:11.760
让我们用它来搞一个lookup协议，logUp协议 

0:14:11.760,0:14:16.720
logUP协议的想法是这样的 

0:14:16.720,0:14:22.560
我们会先让prover承诺向量m

0:14:22.560,0:14:26.850
Nico：好的 

0:14:26.850,0:14:28.640
Ariel：是 -

0:14:28.640,0:14:32.542
这是个重数的向量，我们一般这么称呼它 

0:14:32.542,0:14:37.840
Nico：是的 
Ariel：也就是每个元素出现多少次 

0:14:38.760,0:14:47.520
然后verifier会发送随机的挑战beta 

0:14:47.520,0:14:51.300
Nico：好的 

0:14:51.300,0:15:02.240
Ariel：现在的想法是，如果lookup不满意，如果t中未包含f，

0:15:02.240,0:15:09.100
这个有理恒等式，有非常高的概率在beta的挑战之下并不成立 

0:15:09.100,0:15:13.160
Nico：对 这是我们非常熟悉的Schwartz – Zippel测试 

0:15:13.160,0:15:13.800
Ariel：没错 

0:15:13.800,0:15:16.160
Nico：酷

0:15:16.160,0:15:28.960
Ariel：所以现在基本上P要说服V

0:15:31.440,0:15:40.960
我们引理中的有理恒等式在Beta点成立 

0:15:40.960,0:15:42.760
Nico：好的 

0:15:42.760,0:15:47.760
Ariel：顺便说一句，不同的log derivative方法，

0:15:47.760,0:15:51.300
就是通过如何完成这一步而区分开的不同的log derivative变体的 

0:15:51.300,0:15:51.920
Nico：好的 

0:15:51.920,0:15:55.500
Ariel：它在LogUp，CQ和GKR中都是不同的 

0:15:55.500,0:15:57.740
Nico：所以除此之外它们都遵循相同的范式？

0:15:57.740,0:15:58.400
Ariel：是的 

0:16:00.400,0:16:05.880
Ariel：好的 所以让我们从logUp开始 


0:16:09.640,0:16:13.760
因此，这都是log或类似的 

0:16:13.760,0:16:16.360
我们可以称其为logUp或“常规的”logUp 

0:16:16.360,0:16:17.380
Nico：好的 

0:16:17.380,0:16:22.760
Ariel：那么第3步在在“常规”logUp协议中怎么做呢？

0:16:24.280,0:16:32.440
想法是这些基本就是怎么做步骤3 

0:16:32.440,0:16:33.130
Nico：酷

0:16:33.130,0:16:42.880
Ariel：P会发送对多项式A的承诺 

0:16:42.880,0:16:44.110
Nico：好的 

0:16:44.110,0:16:48.920
Ariel：这个多项式A是什么？

0:16:48.920,0:16:53.000
在这里，就像我之前说的，我会

0:16:53.000,0:16:56.840
在多项式和变量之间来回切换 

0:16:56.840,0:16:58.840
作为一个向量

0:17:01.040,0:17:16.780
Aᵢ的值将会是tᵢ加上beta分之mᵢ减去fᵢ加上beta分之1 

0:17:16.780,0:17:20.620
Nico：好的 我们为什么要这样构建它？

0:17:20.620,0:17:25.114
Ariel：好吧，如果你还记得我们的等式

0:17:25.114,0:17:25.820
Nico：是的 

0:17:25.820,0:17:29.160
Ariel：等式的左边和右边 

0:17:29.160,0:17:32.880
如果我们把右边移项到左侧 

0:17:32.880,0:17:42.480
正确的 这是等式的第i项其中变量x被实例化为beta 

0:17:42.480,0:17:44.200
Nico：好的 

0:17:44.200,0:17:56.840
Ariel：因此，根据基本引理的说法现在已经充分可以让P证明以下 

0:17:57.480,0:18:06.060
首先是A的值是正确的 

0:18:06.060,0:18:09.900
Nico：在m，t和f取好的之后A的值是正确的 

0:18:09.900,0:18:16.700
Ariel：没错 我的意思是，在协议中，P发送了对某个A的承诺 

0:18:16.700,0:18:18.740
Nico：Verifier不知道它是什么 

0:18:18.740,0:18:19.514
Ariel：Verifier

0:18:19.514,0:18:22.400
Nico：好的 
Ariel：应该有这些值 

0:18:22.400,0:18:27.480
首先是P需要证明这些确实是

0:18:27.480,0:18:28.760
这确实是A-

0:18:28.760,0:18:29.430
Nico：好的 

0:18:29.430,0:18:31.560
Ariel： - 是他发送的 

0:18:32.240,0:18:44.180
第二件事Aᵢ的总和为0 

0:18:44.180,0:18:50.220
Nico：这是因为在那个等式里
我们的左边有一些，右边有另一些？

0:18:50.220,0:18:51.520
Ariel：没错 

0:18:51.520,0:18:54.954
所以，给出一个 -

0:18:54.954,0:18:55.660
Nico：是的 

0:18:55.660,0:19:01.720
Ariel：如果条件2成立，那意味着

0:19:01.720,0:19:06.660
之前我们见到的引理中的有理等式在Beta点成立 

0:19:06.660,0:19:07.620
Nico：对 

0:19:07.620,0:19:12.960
Ariel：再一次，由于Beta是在P承诺m后作出选择的，

0:19:14.280,0:19:22.800
如果lookup条件不成立，则有很高的可能性，它不会在Beta处成立 

0:19:22.800,0:19:23.594
所以

0:19:23.594,0:19:23.800
Nico：好的 

0:19:23.800,0:19:29.580
Ariel：这两个足以证明f包含在表中 

0:19:29.580,0:19:31.000
NICO：概率非常高 

0:19:31.000,0:19:33.320
Ariel：在Beta处，可能性非常高 

0:19:33.320,0:19:35.480
Nico：是的 没错 

0:19:35.480,0:19:42.080
Ariel：好的 那么我们如何做1和2？

0:19:43.720,0:19:48.580
我要先跳过1 

0:19:48.580,0:19:49.520
Nico：好的 

0:19:49.520,0:19:55.660
Ariel：尽管我们要在稍后讨论CQ的时候更深入的讨论它 

0:19:55.660,0:19:56.360
Nico：听起来不错 

0:19:56.360,0:20:01.600
Ariel：但是现在我会暂时先不理会它

0:20:01.600,0:20:04.800
这部分是很标准的 

0:20:04.800,0:20:05.680
Nico：好的 

0:20:05.680,0:20:09.120
Ariel：可以用商来完成

0:20:09.120,0:20:15.960
就像我们在snark中做很多事情一样，也可以通过sum check完成 

0:20:15.960,0:20:17.640
Nico：好的 

0:20:17.640,0:20:23.200
Ariel：但是让我们先专注于2，要完成2，

0:20:23.200,0:20:28.640
我们将使用另一个有趣的经常在SNARKs中出现的引理 

0:20:30.920,0:20:34.080
被称为Aurora - 而
我喜欢称呼Aurora引理，

0:20:34.080,0:20:37.140
因为我原本是我在Aurora论文上看到的 

0:20:37.140,0:20:37.680
Nico：好的 

0:20:37.680,0:20:40.000
Ariel：所以让我们看看Aurora引理是什么 

0:20:40.000,0:20:42.360
Nico：是的 

0:20:42.360,0:20:53.240
Ariel：所以Aurora引理告诉我们以下内容 

0:20:53.240,0:21:08.280
因此，就像我们之前设置的一样，假设H是一个阶为n的乘法子群，大小为n 

0:21:08.280,0:21:12.080
Nico：好的 是的，单位根 

0:21:12.080,0:21:16.800
Ariel：没错 是的 和f-

0:21:16.800,0:21:26.480
或者说，我们称之为A，A是一个次数小于n的多项式 

0:21:28.720,0:21:52.120
然后，如果我们观察A在H上的求和这显然等于A（0）处以n 

0:21:52.120,0:21:56.320
等等，另一侧的n是什么？ n分之1在这里 

0:21:56.320,0:21:58.520
Nico：对不起 

0:22:03.680,0:22:05.680
好的 这看起来很神秘 

0:22:05.680,0:22:10.382
Ariel：是的 所以这看起来很神奇 

0:22:10.382,0:22:13.960
Nico：是的 
Ariel：我们可以得到

0:22:13.960,0:22:16.160
假设A的次数比n小，

0:22:16.160,0:22:23.680
我们可以通过观察A(0)来得到它值的求和 

0:22:26.320,0:22:31.280
让我们看看为什么这是成立的 

0:22:31.280,0:22:36.340
所以我们要来研究一下 所谓的拉格朗日基 

0:22:36.340,0:22:37.040
Nico：是的 

0:22:37.040,0:22:51.880
Ariel：那么，令l₁到lₙ为H的拉格朗日基 

0:22:51.880,0:22:56.100
Nico：我想我们在第6个模块讲lookups时讲过这个 

0:22:56.100,0:22:57.440
Ariel：是的，对

0:22:57.440,0:23:03.840
所以这只是这些delta函数，有时候它们被这么称呼 

0:23:03.840,0:23:08.960
l₁（x）只是小于n次的多项式

0:23:08.960,0:23:13.280
它在第i个点上等于1，也就是g的i次方那个点 

0:23:13.280,0:23:14.000
Nico：是的 

0:23:14.000,0:23:17.320
Ariel：并且在其它H上的点得0 

0:23:17.320,0:23:18.960
Nico：好的 

0:23:18.960,0:23:26.800
Ariel：我们现在有一个A,它的次数小于n，

0:23:27.480,0:23:35.960
所以我可以写下它 - 拉格朗日基，他们是小于n的多项式的基 

0:23:35.960,0:23:37.200
所以我可以把A(0)

0:23:37.200,0:23:38.960
Nico：是的 

0:23:38.960,0:23:43.040
Ariel：写成求和，还有

0:23:43.040,0:23:47.800
当我把A写成拉格朗日基的形式时，第i个系数是什么？

0:23:47.800,0:23:52.800
Nico：我们知道吗？我们如何获得系数？

0:23:52.800,0:23:55.440
Ariel：嗯，这就是拉格朗日基的好处

0:23:55.440,0:23:58.640
第i个系数将是

0:23:58.640,0:24:05.160
是的  第i个 -- 函数A在第i个点的值

0:24:05.160,0:24:06.120
Nico：好的 

0:24:06.120,0:24:07.200
Ariel： 在H里的第i个点 

0:24:10.720,0:24:14.480
所以这只是Aᵢ 

0:24:14.480,0:24:17.600
Nico：对 好的 

0:24:17.600,0:24:21.320
Ariel：乘上Lᵢ(0) 

0:24:21.320,0:24:22.080
Nico：对 

0:24:22.080,0:24:26.160
您的意思是以这种Lᵢ形式的系数 

0:24:26.160,0:24:31.593
我认为系数是通常的那种就像a 乘 x和b 乘 x平方那种 

0:24:31.593,0:24:34.360
Ariel：对 所以当我们

0:24:34.360,0:24:37.400
我们早些时候谈惯例约定的时候提到这个 

0:24:37.400,0:24:46.120
当我们在矢量到多项式之间切换的时候，那时，向量的值会成为

0:24:46.120,0:24:51.387
多项式的系数，当我们用H的拉格朗日基的时候，这是成立的 

0:24:51.387,0:24:51.720
Nico：我明白了 好的 

0:24:51.720,0:24:57.098
Ariel：特别地，A（0）会变成

0:24:57.098,0:24:57.840
Nico：这个求和 
Ariel：这个求和 

0:24:59.300,0:25:04.320
Ariel：现在我们有这个很棒的子引理，这个我还留做

0:25:04.320,0:25:14.080
一个习题，它会告诉我们Lagranges在0处都相等 

0:25:14.080,0:25:22.680
因此，对于每个i，lᵢ（0）只是1/n 

0:25:22.680,0:25:24.380
Nico：好的 

0:25:24.380,0:25:28.320
Ariel：所以让我们给这个练习圈在括号里 

0:25:28.320,0:25:29.600
Nico：是的 

0:25:29.600,0:25:35.040
Ariel：现在，鉴于这个良好的事实，这个求和变成了多少？

0:25:35.040,0:25:37.810
它只是1/n 

0:25:37.810,0:25:38.220
Nico：是的 

0:25:38.220,0:25:39.834
Ariel：我们可以提出这个 -

0:25:39.834,0:25:40.440
Nico：是的 

0:25:40.440,0:25:44.440
Ariel：乘以Aᵢ的求和 

0:25:44.440,0:25:50.600
Nico：对 所以我们已经得到了我们想证明的东西 

0:25:50.600,0:25:51.040
真棒 

0:25:51.040,0:25:52.000
Ariel：是的 

0:25:52.000,0:25:53.280
因此，鉴于此 -

0:25:53.280,0:25:57.800
没错 对logUp协议我们想要证明什么？

0:25:57.800,0:26:04.600
我们想证明A在子群上的求和值为0 

0:26:06.040,0:26:11.800
现在这个Aurora引理给了我们一种非常方便的方法 

0:26:11.800,0:26:24.360
P只需将kzg打开A（0）至零 

0:26:24.360,0:26:25.640
Nico：希望如此 

0:26:25.640,0:26:26.640
Ariel：希望如此 

0:26:26.640,0:26:27.280
Nico：对 

0:26:27.280,0:26:36.520
Ariel：如果他成功，据Aurora引理，那么我们在子群上的求和就为0 

0:26:36.520,0:26:38.180
Nico：酷

0:26:38.180,0:26:45.660
Ariel：这意味着有非常高的可能性lookup是成立的  f包含在t中 

0:26:45.660,0:26:51.880
Nico：很棒 那logUp完成了吗？

0:26:51.880,0:26:56.640
Ariel：那是普通的或基本的logUp协议 

0:26:56.640,0:27:01.440
现在我们要看一些变体优化 

0:27:02.120,0:27:10.280
因此，我们下一个要学习的变体是，所谓的CQ，好吧，

0:27:10.280,0:27:17.980
到目前为止，我们已经假设了witness和表的大小相同 

0:27:17.980,0:27:21.582
Nico：是的 我们已经在各处都在用了 

0:27:21.582,0:27:22.160
Ariel：是的 
Nico：酷

0:27:22.160,0:27:33.594
Ariel：对 但是如果t， t的大小，不再是小n 

0:27:33.594,0:27:33.780
Nico：是的 

0:27:33.780,0:27:38.760
Ariel：而是某个大N比n要大得多 

0:27:38.760,0:27:39.540
Nico：好的 

0:27:39.540,0:27:42.840
Ariel：然后，一个有趣的问题是，

0:27:42.840,0:27:54.240
我们可以，经过一些预处理，并且让logUp协议的运行时间仍然依赖于小n？

0:27:54.240,0:28:12.140
所以我们还可以让prover运行时时间仅取决于小N吗？


0:28:13.800,0:28:15.473
Nico：酷但需要加一个双问号 

0:28:15.473,0:28:16.440
Ariel：是的！

0:28:18.040,0:28:21.600
Ariel：这就是我们接下来要看到的 

0:28:21.600,0:28:22.620
Nico：听起来不错 

0:28:22.620,0:28:31.040
Ariel：所以现在在这个问题的背景下，让我们开始谈论CQ协议 

0:28:31.040,0:28:35.680
那将是下一个本讲座的主要部分 

0:28:35.680,0:28:37.480
Nico：听起来不错 我们可以把这些擦掉吗？

0:28:37.480,0:28:38.320
Ariel：擦掉吧 

0:28:42.880,0:28:51.320
那么，在开讲CQ本身之前，我们将要使用的主要主题

0:28:51.320,0:28:59.380
在CQ中与我们使用KZG方案时承诺稀疏多项式有关 

0:28:59.380,0:29:01.420
Nico：好的 稀疏是什么意思？

0:29:01.420,0:29:03.160
Ariel：好的 我们来 -

0:29:03.160,0:29:05.740
是的 这正是我们要定义的 

0:29:05.740,0:29:06.340
Nico：好的 

0:29:06.340,0:29:09.000
Ariel：让我来提醒大家一个

0:29:09.000,0:29:14.680
KZG的非常好用的属性，也就是可加性 

0:29:14.680,0:29:28.040
我的意思是说当给定了f和g的承诺，

0:29:29.800,0:29:38.000
我们有一个性质，如果我想要多项式f+g的承诺，这是

0:29:38.360,0:29:41.200
我可以简单地通过加和这两个承诺来得到这一点 

0:29:41.200,0:29:46.690
Nico：好的 

0:29:46.690,0:29:51.720
Ariel：那么，这跟稀疏多项式有什么关联呢？

0:29:51.720,0:29:53.000
所以首先

0:29:53.000,0:29:54.302
我的意思是什么？

0:29:54.302,0:30:05.400
Nico：是的 
Ariel：所以假设我有一些多项式 

0:30:05.400,0:30:11.120
让我们称它们为P_ 1到P_N，让我在这里使用大N 

0:30:12.960,0:30:18.320
让我们假设这些多项式是线性独立的，

0:30:18.320,0:30:22.960
虽然这对我马上要讲的并不重要，但他们总是会有用的 

0:30:22.960,0:30:26.380
Nico：好的 

0:30:26.380,0:30:45.834
Ariel：所以现在我们说多项式P是在pᵢ中的基上n-稀疏的

0:30:45.834,0:30:48.300
Nico：好的 

0:30:48.300,0:31:07.360
Ariel：如果我可以把P写作为 - Pᵢ的线性组合

0:31:07.360,0:31:20.200
其中只有最多n个i的cᵢ不为零 

0:31:20.200,0:31:25.120
Nico：好的 所以大多数时候此cᵢ将为零 

0:31:25.120,0:31:25.620
Ariel：是的 

0:31:25.620,0:31:29.753
Nico：然后只有n个存在的点在哪它不是零，也就是所谓稀疏 

0:31:29.753,0:31:30.400
Ariel：没错 

0:31:30.400,0:31:33.480
Nico：酷

0:31:33.480,0:31:38.120
Ariel：现在对我们非常有用的是

0:31:38.120,0:31:52.000
让我们假设我们预先计对Pᵢ的承诺 

0:31:52.000,0:31:52.554
所以我们

0:31:52.554,0:31:53.600
Nico：大的那些 

0:31:53.600,0:31:53.900
好的 是的 

0:31:53.900,0:32:05.440
Ariel：是的 我们预先计算对这些Pᵢ的承诺 

0:32:05.440,0:32:06.600
所以我们可以

0:32:06.600,0:32:09.240
现在，我们想计算对P的承诺 

0:32:10.000,0:32:16.800
我们把Pᵢ想成是我们所知道的，这些基底是我们事先知道的 

0:32:17.360,0:32:22.460
但是P是当协议已经启动后我们才会得到的 

0:32:22.460,0:32:25.880
Nico：我的意思是，我们可以猜测你正在用的

0:32:25.880,0:32:31.313
大Ns和小ns - 这可能是要成为我们的表

0:32:31.313,0:32:32.920
Ariel：是的，是的 没错 

0:32:32.920,0:32:36.840
因此，我们现在可以计算对P的承诺 

0:32:39.440,0:32:40.560
没错 

0:32:40.560,0:32:54.800
如果我们将p写为求和cᵢpᵢ，并且现在，我们使用KZG的线性性 

0:32:54.800,0:33:05.040
因此，这与Cᵢ乘上pᵢ的承诺的求和相同 

0:33:05.040,0:33:08.480
其中只有很少的n是非零的 

0:33:08.480,0:33:09.800
Nico：是的 

0:33:09.800,0:33:15.760
Ariel：这里的关键点在于当P是n-稀疏 时，

0:33:15.760,0:33:24.680
这只需要n次数乘 

0:33:24.680,0:33:27.760
Nico：对 

0:33:29.920,0:33:33.840
因为大多数时候Cᵢ是0，所以我们不需要做任何事

0:33:33.840,0:33:36.760
当不是0时，那我们就需要做数乘 

0:33:36.760,0:33:39.982
Ariel：没错 是的 

0:33:39.982,0:33:39.993
Nico：好的 

0:33:39.993,0:33:52.640
Ariel：因此，CQ协议，你可以将其视为有点超过logUp并注意

0:33:52.640,0:34:01.020
观察到所有的多项式在某个我们事先知道的基底上是稀疏的 

0:34:01.020,0:34:01.720
Nico：好的 

0:34:01.720,0:34:06.920
Ariel：所以现在让我们浏览一下logUp协议中出现的一些多项式

0:34:06.920,0:34:15.200
并且看看如何它们拥有这种稀疏性 

0:34:15.200,0:34:17.630
Nico：好的 

0:34:17.630,0:34:23.880
Ariel：还得再来一点，记号 

0:34:23.880,0:34:29.160
因此，在CQ语境中，当我们想到表比witness大

0:34:29.160,0:34:33.200
我们通常也会想到有一个其他子群 

0:34:33.200,0:34:42.600
因此，让我们想到有一个子群V，它的大小为N 

0:34:42.600,0:34:43.380
Nico：对 

0:34:43.380,0:34:57.680
Ariel：现在也许让我们切换符号并使用L表示V的拉格朗日基底 

0:34:57.680,0:34:59.100
Nico：所以在大的集合里 

0:34:59.100,0:35:00.360
Ariel：是的 大集合 

0:35:00.360,0:35:00.900
Nico：酷

0:35:00.900,0:35:07.040
Ariel：所以第一个多项式在logUp中出现的是这个多项式

0:35:07.040,0:35:10.300
m，它描述元素的重数 

0:35:10.300,0:35:10.900
Nico：是的 

0:35:10.900,0:35:15.040
Ariel：因此，在CQ语境中，当表很大时

0:35:15.040,0:35:21.880
我们将在大子群V上编码m 

0:35:21.880,0:35:25.440
所以m会

0:35:25.440,0:35:28.840
现在这个多项式求和mᵢ 

0:35:28.840,0:35:33.920
Nico：对 我们在大群中做到这一点

0:35:33.920,0:35:38.280
因为在我们的等式中，我们有m的求和除以t 

0:35:38.280,0:35:40.760
因此，对于每个t，都有一个m 

0:35:40.760,0:35:43.840
因此，这就是为什么我们需要用大的群？

0:35:43.840,0:35:45.274
Ariel：是的，我们需要

0:35:45.274,0:35:46.120
Nico：好的 

0:35:46.120,0:35:49.040
Ariel：首先，只是写下我们的表格  

0:35:49.040,0:35:51.180
Nico：对 我们需要这个大群 

0:35:51.180,0:35:52.220
Ariel：我们需要这个大群 

0:35:55.320,0:36:01.520
因此，第一件事要注意的是m将是小n 

0:36:01.520,0:36:06.760
再次，如果我们仍在思考我们的witness

0:36:06.760,0:36:20.080
f是一个大小为n的向量，或者等效地多项式 -

0:36:20.080,0:36:33.480
所以现在让我们把H上的拉格朗日基底称作Bᵢ 

0:36:33.480,0:36:37.400
所以H，我们仍把它认为作一个阶为n的子群 

0:36:37.400,0:36:38.400
Nico：好吗？

0:36:38.400,0:36:41.800
Ariel：对 所以  -

0:36:41.800,0:36:48.960
好的 也许要清楚，所以现在我们认为t是大小为N的矢量

0:36:48.960,0:36:57.606
或等价的值在较大的子群V上编码的多项式 

0:36:57.606,0:36:58.800
Nico：是的 好 

0:36:58.800,0:37:05.720
Ariel：是的 再一次，mᵢ是元素的重数 

0:37:06.520,0:37:11.600
那你怎么看？这个多项式在此基底上稀疏吗？

0:37:11.600,0:37:16.320
Nico：我的意思是，如果我们有一个诚实的prover，

0:37:16.320,0:37:20.260
只有这里面的元素有不为零的m 

0:37:20.260,0:37:21.540
Ariel：对 没错 

0:37:21.540,0:37:26.261
Nico：不是f的东西会有0，它们出现零次 

0:37:26.261,0:37:26.660
Ariel：对 
Nico：是的 

0:37:26.660,0:37:27.800
Ariel：是的 

0:37:27.800,0:37:38.360
因此，在此基底上，因为这些描述元素的重数，

0:37:38.360,0:37:42.640
m在lᵢ的基上 
将是n-稀疏的 

0:37:42.640,0:37:46.200
再一次，

0:37:46.200,0:37:57.440
就像我们之前说过的那样，关键是预先计算对lᵢ的承诺，

0:38:01.400,0:38:13.160
我们可以用n次数乘计算cm（m） 

0:38:20.960,0:38:22.440
所以  -

0:38:22.440,0:38:27.600
好的 因此，我们看到第一个在logUp中出现的多项式，我们

0:38:27.600,0:38:31.560
即使表格很大，我们也可以计算它 

0:38:31.560,0:38:35.200
我们可以在一些预处理后计算它

0:38:35.200,0:38:39.000
只需要一些数乘取决于witness的规模 

0:38:39.000,0:38:40.470
Nico：酷

0:38:40.470,0:38:49.800
Ariel：现在是第二个主要logUp出现的多项式是 -

0:38:49.800,0:38:51.240
所以让我们回想一下 好吗？

0:38:51.240,0:38:59.920
当我们描述logUp协议时我们说让我们定义这个多项式 A

0:38:59.920,0:39:08.480
它的值在logUp协议中，它的值像这样 

0:39:08.480,0:39:13.060
Nico：是的 

0:39:13.060,0:39:21.160
Ariel：所以在CQ中，我们差不多是分开处理这一部分和这一部分 

0:39:21.160,0:39:25.360
出于这次演讲的目的 让我们专注于表格部分 

0:39:25.360,0:39:27.360
这将是有趣的部分 

0:39:27.360,0:39:27.780
Nico：当然 

0:39:27.780,0:39:30.200
Ariel：所以让我们假设

0:39:30.200,0:39:32.560
假设这部分不存在 

0:39:32.560,0:39:33.800
Nico：好的 

0:39:33.800,0:39:41.600
Ariel：现在是一件事我们需要在logUp中做

0:39:41.600,0:39:53.600
嗯 我们需要证明这些确实是A的值 

0:39:57.960,0:40:00.640
在描述logUp时，我们说，嗯

0:40:00.640,0:40:04.720
这就像常见的那些事情比如商或sum check 

0:40:04.720,0:40:10.840
那么现在让我们看一下，这件事如何用商完成 

0:40:10.840,0:40:14.920
我们通常如何用商证明这类事情呢？

0:40:14.920,0:40:27.320
我们可以说的是A的值是正确的，当且仅当存在

0:40:28.320,0:40:39.160
商多项式Q，使得 

0:40:39.160,0:40:57.000
如果我看一下A乘以t 加上 beta，然后再取余 - 取余这个子群，它将等于mᵢ 

0:40:57.000,0:41:09.560
所以，他也会等于ZV乘Q(x)加上m(x) 

0:41:09.560,0:41:12.000
Nico：好的 

0:41:12.000,0:41:14.400
Ariel：所以，对 

0:41:14.400,0:41:16.480
所以这是

0:41:16.480,0:41:27.240
我们知道，如果存在这样的Q，则意味着每当我们从V中代入东西时，

0:41:28.000,0:41:30.800
这是在V上消失的多项式 

0:41:30.800,0:41:31.550
Nico：是的 

0:41:31.550,0:41:39.700
Ariel：我们会得到A乘 T 加上 beta等于m 

0:41:39.700,0:41:42.418
Nico：好的 因为这个会当我们代入某些东西时得零

0:41:42.418,0:41:42.680
Ariel 是的 是的 
Nico：好的 

0:41:42.680,0:41:53.840
Ariel：或等效地，A等于m处以T加beta这就是我们要证明的内容 

0:41:53.840,0:41:55.490
Nico：是的 

0:41:55.490,0:42:06.960
Ariel：所以我们的目标是计算对Q的承诺，就像我们对M所做的一样 

0:42:06.960,0:42:15.160
我们的目标是在n次数乘中计算承诺Q  

0:42:15.160,0:42:20.240
Nico：对 再说一次，是这个东西消除了对大N的依赖 

0:42:20.240,0:42:22.914
Ariel：是的 所以，对，次数

0:42:22.914,0:42:28.860
Nico：是的， 
Ariel：Q的次数肯定在大N左右 

0:42:28.860,0:42:29.860
Nico：好的 正确的 

0:42:29.860,0:42:32.440
Ariel：如果你只是在这里看次数，

0:42:32.440,0:42:36.800
这个是大N次，大N，比这个更大 

0:42:36.800,0:42:37.880
是的 

0:42:37.880,0:42:39.880
因此，这里的次数都是大N 

0:42:39.880,0:42:49.080
但是另一点是，等等！如果只计算对Q的承诺是足够的吗？

0:42:51.360,0:42:52.040
因为真的

0:42:52.040,0:42:55.360
我们通常在snark中发生的事情是 -

0:42:55.360,0:42:57.447
Nico：我们要检查这个，在一个随机的点上？

0:42:57.447,0:43:00.262
Ariel：我们要检查这个，在一个随机的点上 

0:43:00.262,0:43:00.273
Nico：好的 

0:43:00.273,0:43:04.320
Ariel：所以在随机点上的检查点，就像通常发生在snark中一样

0:43:04.320,0:43:06.680
只有对Q的承诺对我们来说还不够 

0:43:06.680,0:43:11.600
我们需要Q本身 否则我们将不能够在随机点上打开它 

0:43:11.600,0:43:11.880
Nico：对 

0:43:11.880,0:43:14.700
因为我们需需要计算它，证明我们正确计算了它 

0:43:14.700,0:43:15.520
Ariel：是的 

0:43:15.520,0:43:16.440
Nico：酷

0:43:16.440,0:43:26.560
Ariel：但是KZG的一个很好的功能是检查

0:43:26.560,0:43:33.640
像这样的方程可以直接用承诺检查 

0:43:33.640,0:43:34.960
Nico：好的 

0:43:34.960,0:43:47.000
这是KZG的另一个不错的性质，KZG因为pairings得到了这个形状

0:43:47.000,0:43:50.360
从KZG是基于pairing的事实 

0:43:50.360,0:43:53.400
KZG可以检查

0:43:53.400,0:44:08.520
我们可以直接用承诺来检查二次的恒等式 

0:44:08.520,0:44:14.040
Nico：好的 

0:44:14.040,0:44:17.840
当你说二次的时候，你不是在指多项式的次数，对吗？

0:44:17.840,0:44:18.560
你是在提及

0:44:18.560,0:44:19.280
Ariel：我不是 

0:44:19.280,0:44:24.120
我只是说我们想到多项式作为我们放入变量的东西 不是吗？

0:44:24.120,0:44:24.560
Nico：好的 

0:44:24.560,0:44:26.120
Ariel：所以，对，所以比如这就是

0:44:26.120,0:44:26.800
这是个二次的

0:44:26.800,0:44:29.815
NICO：因为我们要把两个变量乘在一起

0:44:29.815,0:44:31.200
Ariel：是的 正确的 
Nico：好的 好 

0:44:31.200,0:44:35.080
Ariel：这个也是 最多2次的 

0:44:35.080,0:44:36.473
Nico：是的 

0:44:36.473,0:44:39.680
Ariel：所以这是一个黑盒，我不会深入其中 

0:44:39.680,0:44:45.720
但再一次，这个是pairing导致的结果，是的 

0:44:45.720,0:44:52.200
因此，KZG，并且我们有一个多项式作为变量的二次恒等式，

0:44:52.200,0:44:55.730
我们可以直接从承诺中检查正确性

0:44:55.730,0:44:57.160
Nico：不用打开？
Ariel：不用打开 

0:44:57.160,0:44:57.793
Nico：好的 

0:44:57.793,0:44:59.220
Ariel：是的 这是一个非常酷的性质 

0:44:59.220,0:45:01.160
Nico：好的 所以我们还需要处理这个问题？

0:45:01.160,0:45:02.720
我们如何计算承诺？

0:45:02.720,0:45:14.200
现在我们需要做的事情，我们需要找到我们预先知道的一些基底，

0:45:14.200,0:45:17.213
使得Q是小n-稀疏

0:45:17.213,0:45:17.920
Nico：在这组基底上 
Ariel：在这组基底上 

0:45:17.920,0:45:19.300
Nico：好的 

0:45:19.300,0:45:35.000
Ariel：好的 让我们看看怎么才能把Q改写成稀疏的组合

0:45:35.000,0:45:38.920
为简单起见，让我们先暂时忘了logUp的细节

0:45:38.920,0:45:44.637
并且只是先只是想这么一个情形

0:45:44.637,0:45:47.880
在我们有A的情况下 

0:45:47.880,0:45:48.500
Nico：是的 

0:45:48.500,0:45:55.240
Ariel：A在某组基底上是n-Sparse的 

0:45:55.240,0:46:01.040
比如这组拉格朗日基，{lᵢ} 

0:46:01.040,0:46:02.600
Nico：当然 

0:46:02.600,0:46:13.600
Ariel：我们把A写成我们有一些确定的

0:46:13.600,0:46:16.560
我们有一些确定的T 对吗？

0:46:16.560,0:46:31.400
因此T是表格多项式集，我们希望把A * T写成Q * Z + R  

0:46:31.400,0:46:36.320
嗯，写成某种整除加上余数的形式，被Z整除，还有余数 

0:46:36.320,0:46:37.520
Nico：是的 

0:46:37.520,0:46:47.520
Ariel：我们想计算对Q的承诺，对商的承诺

0:46:47.520,0:46:56.840
还有余数，用小n次数乘来完成 

0:46:58.240,0:47:02.880
有点 - 我们之所以可以做到这样从本质上讲是因为

0:47:02.880,0:47:07.800
除法是线性的，稀疏性是继承下来的 

0:47:07.800,0:47:08.760
Nico：好的 

0:47:08.760,0:47:14.800
Ariel：所以我的意思是，让我们以lᵢ的基底来改写这个 

0:47:14.800,0:47:19.080
我们知道一个A是某种对AᵢLᵢ（x）的求和 

0:47:20.680,0:47:26.280
再次，我们知道只有n个是非零的 

0:47:27.920,0:47:34.600
现在让我们预先计算每个lᵢ成含余数除法的形式  

0:47:34.600,0:47:44.760
每一个Lᵢ我们都可以写lᵢ（x）*T（x） 以及余数 

0:47:44.760,0:47:53.114
因此，这会是Qᵢ（x）乘Z -

0:47:53.114,0:47:54.033
Nico：还有R 

0:47:54.033,0:47:56.080
Ariel：加上Rᵢ(x) 

0:47:56.080,0:47:56.840
Nico：好的 

0:47:56.840,0:47:58.800
Ariel：好的 含余数除法，

0:47:58.800,0:48:05.920
我们的意思是 - 关键点在于Rᵢ的次数总是更小 -

0:48:05.920,0:48:08.240
这就是含余数除法的含义 

0:48:08.240,0:48:14.360
我们一直在计算Qᵢ和Rᵢ，这样它的次数比这个更小 

0:48:14.360,0:48:18.193
Nico：我们拿出尽可能多的Z然后我们还有一些R 

0:48:18.193,0:48:20.280
Ariel：我们不能 - 我们总是可以

0:48:20.280,0:48:26.760
我们可以随时改写为此形式其中余数的次数

0:48:27.360,0:48:29.680
小于Z的次数 

0:48:29.680,0:48:31.220
Ariel：否则这就不是余数了 

0:48:31.220,0:48:32.080
Nico：是的，是的 

0:48:32.080,0:48:41.680
Ariel：现在这个想法是为了对每一个i，我们都会预先计算

0:48:41.680,0:48:48.580
对Qᵢ的承诺和对Rᵢ的承诺 

0:48:48.580,0:48:50.160
Nico：好的 

0:48:50.160,0:48:59.360
Ariel：现在我们基本上要使用含余数除法的线性性 

0:48:59.360,0:49:06.480
所以我们是要写下这个- 我们将代入这个东西 

0:49:06.480,0:49:17.560
因此，这是AᵢLᵢ（x）乘 T（x）的求和 对吧？

0:49:17.560,0:49:31.800
也就是求和AᵢLᵢ(X)*T(x) 

0:49:31.800,0:49:38.000
现在在这里，我们将代入这个分解成商和余数 

0:49:38.000,0:49:49.000
因此我们可以将其写为求和 Aᵢ(Qᵢ(X)*Z(X)+Rᵢ(X)) 

0:49:52.640,0:49:56.240
现在让我们提出Z 

0:49:56.840,0:50:07.960
这与求和AᵢQᵢ(X) * Z(X)相同 

0:50:07.960,0:50:09.760
Nico：是的 

0:50:09.760,0:50:14.120
Ariel：加上一些AᵢRᵢ(X) 

0:50:14.120,0:50:18.240
Nico：好的 所以你在这里分配Aᵢ？

0:50:18.240,0:50:18.700
Ariel：是的 

0:50:18.700,0:50:22.320
Nico：然后将Z提到外面去因为它不依赖于i？

0:50:22.320,0:50:27.520
Ariel：是的 确切地 正确的 现在我们看到了

0:50:27.520,0:50:30.280
Nico：这看起来很怪就像含余数的除法一样 

0:50:30.280,0:50:31.800
Ariel：是的 这是

0:50:31.800,0:50:33.080
这是我们的Q 

0:50:33.080,0:50:34.160
Nico：是的 

0:50:34.160,0:50:43.260
Ariel：这是我们的R，现在是这些Q和R，它们在某些基底上稀疏吗？

0:50:43.260,0:50:50.400
Nico：好吧，如果A稀疏，那么我们会有Qᵢ基底上稀疏，Rᵢ的基底上稀疏 

0:50:50.400,0:50:55.280
Ariel：没错 我们知道大多数Aᵢ为零 

0:50:55.280,0:51:05.120
因此，这意味着这个Q和R，就像A在拉格朗日基底上稀疏一样 

0:51:05.120,0:51:13.320
Q会在此Qᵢ基底上稀疏R会在Rᵢ基底上稀疏 

0:51:13.320,0:51:18.280
因此，如果我们预先计算
这就是为什么CQ是缓存商(cache quotients)的缩写 

0:51:18.280,0:51:26.800
这些Qᵢ是 - 这些对Qᵢ的承诺就是我们所说的缓存商 

0:51:26.800,0:51:33.740
我们预先计算它们，以便我们可以
然后快速计算对Q的承诺 

0:51:33.740,0:51:34.880
Nico：很棒 

0:51:34.880,0:51:40.440
Ariel：好的，这就是CQ的基本原理 

0:51:42.720,0:51:47.240
缺点就是有很多，我们需要预先计算的东西 

0:51:47.240,0:51:48.020
Nico：对 

0:51:48.020,0:51:50.400
Ariel：例如，我们需要预先计算

0:51:50.400,0:51:56.520
这些的承诺，大写的N个对这些Qᵢ的承诺 

0:51:56.520,0:51:58.120
Nico：是的 

0:51:58.120,0:52:01.320
Ariel：例如，设置

0:52:01.320,0:52:06.954
我对数字的估计，我们可以
估计，大N是2^40左右量级 

0:52:06.954,0:52:10.160
Nico：好的 
Ariel：然后小n差不多2^20 

0:52:11.520,0:52:19.080
然后我们还没讲到怎么最优地做这些预计算所有这些承诺，但关键是

0:52:19.080,0:52:27.360
它们可以在这些次运算中被计算也就是O(N log(N))

0:52:27.360,0:52:27.560
对吧？

0:52:27.560,0:52:33.714
因此，例如，对于这个N，大约是40乘2^40 

0:52:33.714,0:52:33.880
Nico：是的 

0:52:33.880,0:52:38.400
Ariel：对吗？差不多，我不知道，2^45 

0:52:41.320,0:52:47.120
这就是大概的数量，你需要做这么多次的数乘 

0:52:47.120,0:52:48.600
所以这是

0:52:48.600,0:52:52.480
我估算过，这个计算可能需要几个月的时间 

0:52:52.480,0:52:54.360
Nico：对 

0:52:54.360,0:52:58.260
我想也需要有很多存储空间，因为我们需要保留很多要素 

0:52:58.260,0:53:00.760
Ariel：存储的需求，我认为，是在PB量级 

0:53:00.760,0:53:01.713
Nico：好的 哇 

0:53:01.713,0:53:03.360
Ariel：你需要存储

0:53:03.360,0:53:08.400
对于完整的CQ，你需要存储，我想，这么多元素的七倍 

0:53:08.400,0:53:09.180
Nico：好的 

0:53:09.180,0:53:11.320
Ariel：你从中得到了什么？

0:53:11.320,0:53:16.280
你可以从中得到一个40比特的的表格

0:53:16.280,0:53:19.740
而普通的logUp可能需要使用20比特的表格 

0:53:19.740,0:53:20.640
Nico：我明白了 

0:53:20.640,0:53:26.000
Ariel：那么一个40比特的表格比20比特的好多少呢？

0:53:27.280,0:53:31.300
大了大约一百万倍， 那么好了一百万倍吗？

0:53:31.300,0:53:32.160
Nico：嗯 

0:53:32.160,0:53:36.680
Ariel：嗯，这取决于表格是什么 

0:53:36.680,0:53:39.800
这与表的可分解性概念非常相关

0:53:39.800,0:53:45.240
这个概念在
在lasso的论文中非常突出的体现 

0:53:45.240,0:53:49.594
例如，假设

0:53:49.594,0:53:50.600
Nico：让我们腾出一些空间 

0:53:50.600,0:53:56.440
Ariel：是的 

0:53:59.240,0:54:03.800
我可能需要整个白板 

0:54:03.800,0:54:05.120
好的

0:54:05.120,0:54:13.680
例如，假设表只是40位的字符串 

0:54:13.680,0:54:21.820
作为域元素，表里就是值0，1，直到最高2^40-1 

0:54:21.820,0:54:22.880
Nico：好的 

0:54:22.880,0:54:29.240
Ariel：这是一个例子我们叫做一张可分解的表 

0:54:29.240,0:54:30.080
为什么？

0:54:30.080,0:54:35.560
因为如果我们将T'设置成为20位字符串的表，

0:54:35.560,0:54:39.560
也就是说，值从0到2^20-1 

0:54:40.360,0:54:42.680
嗯呢？这是什么意思？

0:54:42.680,0:54:48.480
这意味着a在T中，当且仅当我们

0:54:48.480,0:55:00.440
可以把它写作求和a₁ + 2^20a₂，其中a₁和a₂在T'中 

0:55:00.440,0:55:01.360
Nico：对 

0:55:01.360,0:55:03.720
因此，实际上，总结这个 -

0:55:03.720,0:55:06.222
例如，我们可以使用这些表进行范围检查吗？

0:55:06.222,0:55:08.080
Ariel：是的 
NICO：检查某物是否在2^40以内 

0:55:08.080,0:55:08.620
Ariel：是的 

0:55:08.620,0:55:13.200
我们可以不用在这个巨大的表中查找，而是我们可以在这这两个东西中查找 

0:55:13.200,0:55:13.902
Ariel：对 

0:55:13.902,0:55:13.913
Nico：好的 

0:55:13.913,0:55:19.160
Ariel：所以我们看到，例如这张表，我们可以模拟这个大表中的查找

0:55:19.160,0:55:24.480
通过两个在这个表中的查找，T' ，可能是 我们不需要CQ 

0:55:24.480,0:55:32.380
我们可以使用常规logUp和某种线性约束，线性组合门 

0:55:32.380,0:55:37.760
Nico：所以实际上， 即使回到模块6，我们用比特分解为我们的例子，

0:55:37.760,0:55:41.520
这是一种混合仅用约束或仅用查找 

0:55:41.520,0:55:43.000
在这里，我们在用介于两者之间的东西 

0:55:43.000,0:55:43.800
Ariel：是的 

0:55:43.800,0:55:49.880
所以在这些表中，人们称其为可分解的，就像说，好吧，

0:55:49.880,0:55:58.400
大表上的查找不是100％由较小表中的查找模拟，

0:55:58.400,0:56:05.080
而是较小表中的几个查找以及最少的一些约束 

0:56:05.080,0:56:07.040
对于一个线性组合门 

0:56:07.040,0:56:08.340
Nico：是的 酷 

0:56:08.340,0:56:12.560
Ariel：所以你的表的结构越多，

0:56:12.560,0:56:19.040
你可能越不想经历这个痛苦的CQ预计算 

0:56:19.040,0:56:19.920
Nico：对 

0:56:19.920,0:56:26.040
Ariel：因此，CQ的好用例是当表上只有些疯狂的值时 

0:56:26.040,0:56:31.380
比如你有一组2^40，我不知道，一组看起来完全随机的字符串 

0:56:31.380,0:56:31.840
Nico：对 

0:56:31.840,0:56:32.640
他们没有结构 

0:56:32.640,0:56:34.060
Ariel：是的 所以那是 -

0:56:34.060,0:56:38.400
这些情况下是CQ可能会非常有用 

0:56:38.400,0:56:45.580
好的 所以要收尾这个讲座，我想谈谈GKR在这个环境中的位置 

0:56:45.580,0:56:47.960
Nico：我们经常听到sum check GKR 

0:56:47.960,0:56:49.040
Ariel：是的 

0:56:49.040,0:57:01.320
因此，一个logUp，或CQ中的痛点是是需承诺很大的值 

0:57:01.320,0:57:07.240
因此，让我们看看我们在logUp中遇到的的值都是什么 

0:57:07.240,0:57:14.100
我们有重数mᵢ 这些通常是小的数字 

0:57:14.100,0:57:14.760
Nico：是的 

0:57:14.760,0:57:15.950
Ariel：如果witness -

0:57:15.950,0:57:18.200
Nico：它出现一次，两次，三次，四次，然后witness 

0:57:18.200,0:57:21.320
Ariel：是的 他们的总和最多将是n 

0:57:21.320,0:57:22.360
Nico：好的 

0:57:22.360,0:57:29.400
Ariel：说我们可以这么说，好的 也许值tᵢ很小 

0:57:29.400,0:57:30.800
我的意思是，这取决于表 

0:57:30.800,0:57:37.834
但是对这样的表，他们将是小的数 

0:57:37.834,0:57:40.320
Nico：小？我们是说与域的大小相比小 

0:57:40.320,0:57:41.640
Ariel：小 

0:57:41.640,0:57:43.640
是的 我们说的很小 

0:57:43.640,0:57:48.834
好吧，与域相比很小，我想很小

0:57:48.834,0:57:49.320
Nico：总体上？

0:57:49.320,0:57:52.640
Ariel：总体上 是的 

0:57:52.640,0:57:53.593
Nico：好的 

0:57:53.593,0:57:56.840
Ariel：但是在哪里

0:57:56.840,0:58:02.440
是的 因为它们的大小会有点影响承诺需要的时间 

0:58:02.440,0:58:03.720
Nico：好的 

0:58:03.720,0:58:11.360
Ariel：好的 但这是我们会有些痛苦地方 

0:58:11.360,0:58:13.500
正确的 我们有这些值 

0:58:13.500,0:58:15.480
Nico：是的 

0:58:15.480,0:58:17.040
Ariel：是的 正确的 

0:58:17.040,0:58:20.760
这个或者也许是这个加fᵢ加beta分之1 

0:58:20.760,0:58:23.200
但是，让我们只看这个先，作为例子 

0:58:23.200,0:58:23.870
Nico：当然 

0:58:23.870,0:58:25.720
Ariel：这并不重要 

0:58:25.720,0:58:31.320
关键是我们面临着这个巨大的挑战beta 因此，即使不大

0:58:31.320,0:58:33.360
我们正在用它的倒数 所以 

0:58:33.360,0:58:34.500
Nico：是的 

0:58:34.500,0:58:37.080
Ariel：这就像是一定大小的域

0:58:37.080,0:58:44.500
256比特，这是一个完整的256比特的值，即使mᵢ和tᵢ很小 

0:58:44.500,0:58:45.280
Nico：对 

0:58:45.280,0:58:55.760
Ariel：所以我们理想中希望避免被迫承诺这些值 

0:58:56.360,0:59:00.320
为什么我们需要承诺他们？

0:59:00.320,0:59:06.920
我们的目标是证明一些比如像Aᵢ求和等于0之类的事 

0:59:06.920,0:59:07.880
Nico：是的 

0:59:07.880,0:59:11.360
并且也确实是这些值  

0:59:11.360,0:59:13.040
好的 

0:59:13.040,0:59:18.880
Ariel：对 正确的，我的意思是，假设

0:59:18.880,0:59:19.520
是的，是的 -

0:59:20.560,0:59:30.360
我们想要的是证明

0:59:30.360,0:59:38.840
好的 让我们回到完整的东西？我们想证明这个求和是0 对吗？

0:59:38.840,0:59:41.051
这就是我们真正想证明的 

0:59:41.051,0:59:41.073
Nico：是的 是的，

0:59:41.073,0:59:46.040
Ariel：我们这样做的方式是我们承诺这些值，

0:59:46.040,0:59:51.300
然后证明我们真的承诺了这些值，且它们的总和为0 

0:59:51.300,0:59:51.840
Nico：是的 

0:59:51.840,0:59:56.800
Ariel：但是也许有某种直接从我们已有的承诺中

0:59:56.800,1:00:04.520
我们以后m，t和f的承诺 也许有一种更直接的方法，而无需任何

1:00:04.520,1:00:10.760
额外承诺，比如承诺这个A，并证明该求和为0 

1:00:11.440,1:00:19.520
这个才是GKR协议允许我们做的事情 

1:00:19.520,1:00:25.480
好的 所以让我们腾出一些空间，以便我们可以对GKR的原理讲几句 

1:00:25.480,1:00:29.080
Nico：听起来不错 

1:00:29.080,1:00:30.680
Ariel：所以GKR中的想法

1:00:30.680,1:00:33.240
是的，在Snarks中，我们经常谈论电路 

1:00:33.240,1:00:35.520
再次，假设我们有一些电路

1:00:35.520,1:00:38.600
我们有一个输入，并且有一个加法门 

1:00:38.600,1:00:42.760
也许我们有一个乘法门 

1:00:45.360,1:00:46.520
我不知道 

1:00:46.520,1:00:51.360
通常在电路中，我们要做的是证明有关电路的某些内容，

1:00:51.360,1:00:58.280
但是我们有输入值，但我们也有中间值，门的值 

1:00:58.280,1:01:02.640
通常，当我们想证明关于电路的某事，我们将不仅承诺

1:01:02.640,1:01:08.160
输入，我们还将承诺所有中间值 

1:01:08.160,1:01:15.520
GKR说的是当我们的电路非常非常结构化，

1:01:18.000,1:01:24.940
我们可以证明有关电路输出的信息而仅需要承诺输入层 

1:01:24.940,1:01:28.400
Nico：好的 这个例子中什么叫非常结构化？

1:01:28.400,1:01:32.240
Ariel：好吧，我们的情况是什么？

1:01:32.240,1:01:32.360
正确的？

1:01:32.360,1:01:39.640
我们的情况是我们有输入，让我们称呼它们 -

1:01:39.640,1:01:44.440
同样，让我们​​为了简单起见，只要看表的部分 

1:01:44.440,1:01:47.560
所以我们说 看这个简化的方程式

1:01:47.560,1:01:51.360
比我们在logUp中实际用的要简化，例如，我们有输入

1:01:51.360,1:02:01.640
这些重数，m₁到mₙ以及表值t₁到tₙ 

1:02:01.640,1:02:05.520
我们也有挑战Beta 但假设我们只有这些 

1:02:05.520,1:02:09.280
假设我们想计算

1:02:09.280,1:02:16.400
我们希望输出是这个分数求和tᵢ分之mᵢ 

1:02:16.400,1:02:17.560
Nico：好的 

1:02:17.560,1:02:19.894
我们在这里简化，先不管Beta 

1:02:19.894,1:02:22.394
Ariel：是的 我们令Beta是0，我们也没管f，但是 -

1:02:22.394,1:02:23.860
Nico：它将以相同的方式工作 

1:02:23.860,1:02:25.000
Ariel：这会起作用 -

1:02:25.000,1:02:26.560
它将以相同的方式工作 

1:02:26.560,1:02:27.320
Nico：好的 

1:02:27.320,1:02:37.040
Ariel：所以现在我们想要一个电路这些是输入，这是输出 

1:02:38.320,1:02:44.480
在这个logUp GKR的论文中重点是，

1:02:45.120,1:02:49.640
顺便说一下，它在TaSSLE的那篇论文中也有被很好的讲解 

1:02:49.640,1:02:55.560
我们可以在电路中计算这个，简单的意思是

1:02:55.560,1:03:01.120
对于GKR来说，理想的情况是，最简单的情况是我们有

1:03:01.120,1:03:07.960
分层电路并且所有的门都是一样的，相同的门 

1:03:07.960,1:03:08.530
Nico：好的 

1:03:08.530,1:03:09.960
Ariel：同一种门 

1:03:09.960,1:03:14.520
Nico：所以分层是指我们有一个门，2进1出

1:03:14.520,1:03:17.640
然后又是另一层同样的门，2进1出，然后继续这个规律？

1:03:17.640,1:03:23.080
Ariel：是的 例如最简单的事情就是二叉树 

1:03:23.080,1:03:26.240
我们有输入

1:03:26.240,1:03:30.180
因此，让我们把我们的输入专注于这种情况 

1:03:30.180,1:03:30.600
Nico：是的 

1:03:30.600,1:03:33.800
Ariel：让我们把输入想成

1:03:33.800,1:03:35.380
让我们交替一下ms和ts 

1:03:35.380,1:03:35.780
Nico：当然 

1:03:35.780,1:03:47.674
Ariel：所以我们说m₁，t₁，m₂，t₂，等等等等，mₙ-1，tₙ-1，mₙtₙ 

1:03:47.674,1:03:47.920
Nico：酷

1:03:47.920,1:03:54.520
现在让我们看一下这个电路，就像你说的那样，是一棵二叉树 

1:03:57.600,1:04:03.680
哪个词来着？四叉树 

1:04:03.680,1:04:04.400
Nico：当然 

1:04:04.400,1:04:05.880
Ariel：四叉树 

1:04:12.040,1:04:20.840
我们想要这样的电路，输出最终将是求和mᵢ/tᵢ 

1:04:21.840,1:04:33.000
所以我们想要的是输入m₁，t₁，m₂，t₂的电路 

1:04:33.000,1:04:34.740
Nico：是的 

1:04:34.740,1:04:45.680
Ariel：并输出t₁分之m₁，然后加上t₂分之m₂ 

1:04:46.520,1:04:47.120
但是让我们

1:04:47.120,1:04:53.760
这么想会容易一些，让我们摆脱这些分数 

1:04:53.760,1:05:04.880
把分数A/B想成一个数对（A，B）会容易一些 

1:05:04.880,1:05:11.480
Nico：好的 我们最后再处理除法，还是说这只是一种记号？

1:05:11.480,1:05:14.880
Ariel：嗯，有点像在电路内 -

1:05:14.880,1:05:16.600
是的，我们可以 - 对，我们稍后再处理 

1:05:16.600,1:05:18.840
我们在电路里会一直用这种方式

1:05:18.840,1:05:21.600
来表示分数操作 

1:05:21.600,1:05:24.260
最后，你将获得一些数对 

1:05:24.260,1:05:25.273
Nico：我明白了 

1:05:25.273,1:05:28.019
Ariel：然后，你可以 - 如果你想的话

1:05:28.019,1:05:29.680
Nico：明白了 
Ariel：再去对数对做除法 

1:05:31.280,1:05:36.600
对，在这个记号中，这是m₁ 

1:05:36.600,1:05:39.720
让我们做一通分 

1:05:39.720,1:05:46.300
这将是 - 让我们做点计算 

1:05:46.300,1:05:47.680
Nico：m₁，t₂ 
Ariel：是的 我认为这是m₁，t₂ 

1:05:47.680,1:05:49.000
Nico：m₂，t₁ 

1:05:49.000,1:05:51.274
Ariel：谢谢  m₂，t₁-

1:05:51.274,1:05:53.120
Nico：在这些t的积之上  

1:05:53.120,1:05:57.560
Ariel：是的，我认为这是t₁，t₂ 

1:05:57.560,1:05:59.720
Nico：是的 

1:05:59.720,1:06:03.040
Ariel：那么这些门，它们会是什么呢？

1:06:03.040,1:06:10.080
他们会是把四个元素映射到两个元素的门 

1:06:10.080,1:06:11.800
Nico：酷

1:06:11.800,1:06:13.960
Ariel：从这里到这里 

1:06:13.960,1:06:22.160
所以GKR，它使用sum check以这种递归的方式 

1:06:22.160,1:06:26.640
关键是当我们有一个像二叉树

1:06:26.640,1:06:30.960
一样的电路，并且所有的门都是一样的 

1:06:30.960,1:06:38.360
这些门现在需要四个输入，像这样，并将它们映射到两个输出 

1:06:38.360,1:06:43.400
GKR在这样的电路上非常有效 

1:06:43.400,1:06:47.920
它很吸引人的特点是，你只需要承诺它们的输入

1:06:47.920,1:06:56.880
而你不需要承诺这些中间层的中间值 

1:07:00.320,1:07:04.880
是的，也许是对的 或许  -

1:07:04.880,1:07:12.320
没错 实际上，如果你仔细想，我们并没有把事情过度简化

1:07:12.320,1:07:15.234
如果我们加上这个大beta

1:07:15.234,1:07:16.680
Nico：当然 
Ariel：对吗？那不是

1:07:16.680,1:07:19.160
那不会

1:07:19.160,1:07:22.744
好吧，也许我们没必要全写出来把白板弄乱 

1:07:22.744,1:07:25.720
Nico：是的 但我认为我们可以想象Beta将如何出现在这里，这里，

1:07:25.720,1:07:29.280
然后在这里，这里，然后在这里和这里 

1:07:29.280,1:07:34.120
Ariel：是的，是的 但是让我们别弄混淆 让我们擦掉它  

1:07:35.200,1:07:37.640
Ariel：好的 那就是 

1:07:37.640,1:07:46.600
是的 这就是GKR怎么可以帮助我们在使用logUp时避免承诺那些巨大的值 

1:07:46.600,1:07:50.200
NICO：我们是否可以用CQ

1:07:50.200,1:07:55.440
来搞定这个大N表格，然后结合使用GKR？还是不行？

1:07:55.440,1:07:56.720
Ariel：我的意思是 

1:07:56.720,1:08:03.640
实际上，这是一个很好的问题 

1:08:03.640,1:08:11.540
我需要思考一下，但我认为与witness有关的部分你可以这么做 

1:08:11.540,1:08:12.300
Nico：好的 

1:08:12.300,1:08:17.680
Ariel：是的 对于那些必须用这些缓存的商来做表格的部分，

1:08:17.680,1:08:19.560
我认为可能不太合适，

1:08:19.560,1:08:25.000
但是，是的，我们放在一边的部分，像fᵢ+beta分之1的那些部分，

1:08:25.560,1:08:28.960
是的，你可以在GKR的同时使用CQ

1:08:28.960,1:08:30.980
Nico：所以我想这个就是这堂课的结尾了？

1:08:30.980,1:08:32.080
Ariel：就是这样 

1:08:32.080,1:08:33.720
Nico：很棒 谢谢 

1:08:33.720,1:08:39.160
让我尝试总结一下，我们讲过的东西，来整理一下 

1:08:39.160,1:08:46.680
我们首先看了一张地图
关于各种lookup，然后我们对log derivatives

1:08:46.680,1:08:51.280
进行了深入细致的探讨，这个你把它描述为分数和 

1:08:51.280,1:08:53.480
我认为这更具描述性 

1:08:53.480,1:08:54.080
Ariel：是的 

1:08:54.080,1:08:58.720
Nico：然后在那个范畴内，原始的logUp协议，然后

1:08:58.720,1:09:04.340
CQ和大表预计算的想法，最后是如何用GKR避免承诺大的中间值 

1:09:04.340,1:09:05.220
Ariel：没错 

1:09:05.220,1:09:06.240
Nico：很棒 

1:09:06.240,1:09:22.080
Ariel，非常感谢！最后，感谢你的观看！

